{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","~lib/gc.ts","~lib/rt.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","assembly/index.ts","~lib/array.ts","~lib/util/number.ts","~lib/util/string.ts","~lib/number.ts","~lib/math.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\r\n\r\n// @ts-ignore: decorator\r\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\r\n// @ts-ignore: decorator\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n// Extra debugging\r\n\r\n// @ts-ignore: decorator\r\n@inline export const DEBUG = true;\r\n\r\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                           MM info                             │ -16\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                           GC info                             │ -12\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                          runtime id                           │ -8\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                         runtime size                          │ -4\r\n// ╞═══════════════════════════════════════════════════════════════╡\r\n// │                              ...                              │ ref\r\n@unmanaged export class BLOCK {\r\n  /** Memory manager info. */\r\n  mmInfo: usize; // WASM64 needs adaption\r\n  /** Garbage collector info. */\r\n  gcInfo: u32;\r\n  /** Runtime class id. */\r\n  rtId: u32;\r\n  /** Runtime object size. */\r\n  rtSize: u32;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\r\n// │                             count                             │\r\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\r\n// │                      Typeinfo#flags [id=0]                    │ id < count\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\r\n// │                      Typeinfo#base  [id=0]                    │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              ...                              │\r\n\r\n/** Runtime type information data structure. */\r\n@unmanaged\r\nexport class Typeinfo {\r\n  /** Flags describing the shape of this class type. */\r\n  flags: TypeinfoFlags;\r\n  /** Base class id or `0` if none. */\r\n  base: u32;\r\n}\r\n\r\n/** Runtime type information flags. */\r\nexport const enum TypeinfoFlags {\r\n  /** No specific flags. */\r\n  NONE = 0,\r\n  /** Type is an `ArrayBufferView`. */\r\n  ARRAYBUFFERVIEW = 1 << 0,\r\n  /** Type is an `Array`. */\r\n  ARRAY = 1 << 1,\r\n  /** Type is a `Set`. */\r\n  SET = 1 << 2,\r\n  /** Type is a `Map`. */\r\n  MAP = 1 << 3,\r\n  /** Type is inherently acyclic. */\r\n  ACYCLIC = 1 << 4,\r\n  /** Value alignment of 1 byte. */\r\n  VALUE_ALIGN_0 = 1 << 5,\r\n  /** Value alignment of 2 bytes. */\r\n  VALUE_ALIGN_1 = 1 << 6,\r\n  /** Value alignment of 4 bytes. */\r\n  VALUE_ALIGN_2 = 1 << 7,\r\n  /** Value alignment of 8 bytes. */\r\n  VALUE_ALIGN_3 = 1 << 8,\r\n  /** Value alignment of 16 bytes. */\r\n  VALUE_ALIGN_4 = 1 << 9,\r\n  /** Value is a signed type. */\r\n  VALUE_SIGNED = 1 << 10,\r\n  /** Value is a float type. */\r\n  VALUE_FLOAT = 1 << 11,\r\n  /** Value type is nullable. */\r\n  VALUE_NULLABLE = 1 << 12,\r\n  /** Value type is managed. */\r\n  VALUE_MANAGED = 1 << 13,\r\n  /** Key alignment of 1 byte. */\r\n  KEY_ALIGN_0 = 1 << 14,\r\n  /** Key alignment of 2 bytes. */\r\n  KEY_ALIGN_1 = 1 << 15,\r\n  /** Key alignment of 4 bytes. */\r\n  KEY_ALIGN_2 = 1 << 16,\r\n  /** Key alignment of 8 bytes. */\r\n  KEY_ALIGN_3 = 1 << 17,\r\n  /** Key alignment of 16 bytes. */\r\n  KEY_ALIGN_4 = 1 << 18,\r\n  /** Key is a signed type. */\r\n  KEY_SIGNED = 1 << 19,\r\n  /** Key is a float type. */\r\n  KEY_FLOAT = 1 << 20,\r\n  /** Key type is nullable. */\r\n  KEY_NULLABLE = 1 << 21,\r\n  /** Key type is managed. */\r\n  KEY_MANAGED = 1 << 22\r\n}\r\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\r\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\r\nimport { TypeinfoFlags } from \"shared/typeinfo\";\r\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\r\n\r\n/////////////////////////// A Pure Reference Counting Garbage Collector ///////////////////////////\r\n// see:     https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\r\n\r\n// ╒══════════════════════ GC Info structure ══════════════════════╕\r\n// │  3                   2                   1                    │\r\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\r\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │B│color│                     refCount                          │\r\n// └─┴─────┴───────────────────────────────────────────────────────┘\r\n// B: buffered\r\n\r\n// @ts-ignore: decorator\r\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BITS = 3;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\r\n\r\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\r\n// │ Color  │ Meaning                                              │\r\n// ├────────┼──────────────────────────────────────────────────────┤\r\n// │ BLACK  │ In use or free                                       │\r\n// │ GRAY   │ Possible member of cycle                             │\r\n// │ WHITE  │ Member of garbage cycle                              │\r\n// │ PURPLE │ Possible root of cycle                               │\r\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\r\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\r\n// └────────┴──────────────────────────────────────────────────────┘\r\n// Acyclic detection has been decoupled, hence no GREEN.\r\n\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\r\n\r\n// @ts-ignore: decorator\r\n@inline const VISIT_DECREMENT = 1; // guard 0\r\n// @ts-ignore: decorator\r\n@inline const VISIT_MARKGRAY = 2;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCAN = 3;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCANBLACK = 4;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_COLLECTWHITE = 5;\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nfunction __visit(ref: usize, cookie: i32): void {\r\n  if (ref < __heap_base) return;\r\n  var s = changetype<Block>(ref - BLOCK_OVERHEAD);\r\n  switch (cookie) {\r\n    case VISIT_DECREMENT: {\r\n      decrement(s);\r\n      break;\r\n    }\r\n    case VISIT_MARKGRAY: {\r\n      if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\r\n      s.gcInfo = s.gcInfo - 1;\r\n      markGray(s);\r\n      break;\r\n    }\r\n    case VISIT_SCAN: {\r\n      scan(s);\r\n      break;\r\n    }\r\n    case VISIT_SCANBLACK: {\r\n      let info = s.gcInfo;\r\n      assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n      s.gcInfo = info + 1;\r\n      if ((info & COLOR_MASK) != COLOR_BLACK) {\r\n        scanBlack(s);\r\n      }\r\n      break;\r\n    }\r\n    case VISIT_COLLECTWHITE: {\r\n      collectWhite(s);\r\n      break;\r\n    }\r\n    default: if (DEBUG) assert(false);\r\n  }\r\n}\r\n\r\n/** Increments the reference count of the specified block by one.*/\r\nfunction increment(s: Block): void {\r\n  var info = s.gcInfo;\r\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n  s.gcInfo = info + 1;\r\n  if (isDefined(ASC_RTRACE)) onincrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n}\r\n\r\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\r\nfunction decrement(s: Block): void {\r\n  var info = s.gcInfo;\r\n  var rc = info & REFCOUNT_MASK;\r\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n  if (rc == 1) {\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\r\n    if (!(info & BUFFERED_MASK)) {\r\n      freeBlock(ROOT, s);\r\n    } else {\r\n      s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\r\n    }\r\n  } else {\r\n    if (DEBUG) assert(rc > 0);\r\n    if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\r\n      s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\r\n      if (!(info & BUFFERED_MASK)) {\r\n        appendRoot(s);\r\n      }\r\n    } else {\r\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\r\n    }\r\n  }\r\n}\r\n\r\n/** Buffer of possible roots. */\r\n// @ts-ignore: decorator\r\n@lazy var ROOTS: usize;\r\n/** Current absolute offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var CUR: usize = 0;\r\n/** Current absolute end offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var END: usize = 0;\r\n\r\n/** Appends a block to possible roots. */\r\nfunction appendRoot(s: Block): void {\r\n  var cur = CUR;\r\n  if (cur >= END) {\r\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\r\n    cur = CUR;\r\n  }\r\n  store<Block>(cur, s);\r\n  CUR = cur + sizeof<usize>();\r\n}\r\n\r\n/** Grows the roots buffer if it ran full. */\r\nfunction growRoots(): void {\r\n  var oldRoots = ROOTS;\r\n  var oldSize = CUR - oldRoots;\r\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\r\n  var newRoots = __alloc(newSize, 0);\r\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n  memory.copy(newRoots, oldRoots, oldSize);\r\n  if (oldRoots) {\r\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n    __free(oldRoots);\r\n  }\r\n  ROOTS = newRoots;\r\n  CUR = newRoots + oldSize;\r\n  END = newRoots + newSize;\r\n}\r\n\r\n/** Collects cyclic garbage. */\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __collect(): void {\r\n\r\n  // markRoots\r\n  var roots = ROOTS;\r\n  var cur = roots;\r\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    let info = s.gcInfo;\r\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\r\n      markGray(s);\r\n      store<Block>(cur, s);\r\n      cur += sizeof<usize>();\r\n    } else {\r\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\r\n        freeBlock(ROOT, s);\r\n      } else {\r\n        s.gcInfo = info & ~BUFFERED_MASK;\r\n      }\r\n    }\r\n  }\r\n  CUR = cur;\r\n\r\n  // scanRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    scan(load<Block>(pos));\r\n  }\r\n\r\n  // collectRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\r\n    collectWhite(s);\r\n  }\r\n  CUR = roots;\r\n}\r\n\r\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\r\nfunction markGray(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\r\n  }\r\n}\r\n\r\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\r\nfunction scan(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\r\n    if ((info & REFCOUNT_MASK) > 0) {\r\n      scanBlack(s);\r\n    } else {\r\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\r\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\r\n    }\r\n  }\r\n}\r\n\r\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\r\nfunction scanBlack(s: Block): void {\r\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\r\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\r\n}\r\n\r\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\r\nfunction collectWhite(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\r\n    freeBlock(ROOT, s);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __retain(ref: usize): usize {\r\n  if (ref > __heap_base) increment(changetype<Block>(ref - BLOCK_OVERHEAD));\r\n  return ref;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __release(ref: usize): void {\r\n  if (ref > __heap_base) decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\r\n}\r\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\r\nimport { onfree, onalloc } from \"./rtrace\";\r\nimport { REFCOUNT_MASK } from \"./pure\";\r\n\r\n/////////////////////// The TLSF (Two-Level Segregate Fit) memory allocator ///////////////////////\r\n//                             see: http://www.gii.upv.es/tlsf/\r\n\r\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\r\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴───────╨───────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_BITS: u32 = 4;\r\n// @ts-ignore: decorator\r\n@inline const SL_SIZE: usize = 1 << <usize>SL_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\r\n// @ts-ignore: decorator\r\n@inline const SB_SIZE: usize = 1 << <usize>SB_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const FL_BITS: u32 = 31 - SB_BITS;\r\n\r\n// [00]: < 256B (SB)  [12]: < 1M\r\n// [01]: < 512B       [13]: < 2M\r\n// [02]: < 1K         [14]: < 4M\r\n// [03]: < 2K         [15]: < 8M\r\n// [04]: < 4K         [16]: < 16M\r\n// [05]: < 8K         [17]: < 32M\r\n// [06]: < 16K        [18]: < 64M\r\n// [07]: < 32K        [19]: < 128M\r\n// [08]: < 64K        [20]: < 256M\r\n// [09]: < 128K       [21]: < 512M\r\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\r\n// [11]: < 512K\r\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\r\n\r\n// Tags stored in otherwise unused alignment bits\r\n\r\n// @ts-ignore: decorator\r\n@inline const FREE: usize = 1 << 0;\r\n// @ts-ignore: decorator\r\n@inline const LEFTFREE: usize = 1 << 1;\r\n// @ts-ignore: decorator\r\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\r\n\r\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┼─┤ overhead   ┐\r\n// │                          size                           │0│L│F│ ◄─┐ info\r\n// ├─────────────────────────────────────────────────────────┴─┴─┴─┤   │\r\n// │                                                               │   │\r\n// │               ... additional runtime overhead ...             │   │\r\n// │                                                               │   │\r\n// ╞═══════════════════════════════════════════════════════════════╡   │      ┐ ┘\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                             ...                               │   │    = 0\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: back ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ payload  ┘ >= MIN SIZE\r\n// F: FREE, L: LEFTFREE\r\n@unmanaged export class Block extends BLOCK {\r\n\r\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\r\n  next: Block | null;\r\n\r\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\r\n}\r\n\r\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\r\n// `next` and `back` if free.\r\n\r\n// @ts-ignore: decorator\r\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\r\n// @ts-ignore: decorator\r\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\r\n\r\n/** Gets the left block of a block. Only valid if the left block is free. */\r\n// @ts-ignore: decorator\r\n@inline function GETFREELEFT(block: Block): Block {\r\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\r\n}\r\n\r\n/** Gets the right block of of a block by advancing to the right by its size. */\r\n// @ts-ignore: decorator\r\n@inline function GETRIGHT(block: Block): Block {\r\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\r\n}\r\n\r\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                           slMap[22]                           │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[367]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                             tail                              │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map\r\n@unmanaged class Root {\r\n  /** First level bitmap. */\r\n  flMap: usize;\r\n}\r\n\r\n// Root constants. Where stuff is stored inside of the root structure.\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_START = sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const SL_END = SL_START + (FL_BITS << alignof<u32>());\r\n// @ts-ignore: decorator\r\n@inline const HL_START = (SL_END + AL_MASK) & ~AL_MASK;\r\n// @ts-ignore: decorator\r\n@inline const HL_END = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const ROOT_SIZE = HL_END + sizeof<usize>();\r\n\r\n// @ts-ignore: decorator\r\n@lazy export var ROOT: Root;\r\n\r\n/** Gets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function GETSL(root: Root, fl: usize): u32 {\r\n  return load<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Sets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\r\n  store<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    slMap,\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Gets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\r\n  return load<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Sets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\r\n  store<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    head,\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Gets the tail block.. */\r\n// @ts-ignore: decorator\r\n@inline function GETTAIL(root: Root): Block {\r\n  return load<Block>(\r\n    changetype<usize>(root),\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Sets the tail block. */\r\n// @ts-ignore: decorator\r\n@inline function SETTAIL(root: Root, tail: Block): void {\r\n  store<Block>(\r\n    changetype<usize>(root),\r\n    tail,\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Inserts a previously used block back into the free list. */\r\nfunction insertBlock(root: Root, block: Block): void {\r\n  if (DEBUG) assert(block); // cannot be null\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n\r\n  // merge with right block if also free\r\n  if (rightInfo & FREE) {\r\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, right);\r\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\r\n      right = GETRIGHT(block);\r\n      rightInfo = right.mmInfo;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  // merge with left block if also free\r\n  if (blockInfo & LEFTFREE) {\r\n    let left = GETFREELEFT(block);\r\n    let leftInfo = left.mmInfo;\r\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\r\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, left);\r\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\r\n      block = left;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  right.mmInfo = rightInfo | LEFTFREE;\r\n  // right is no longer used now, hence rightInfo is not synced\r\n\r\n  // we now know the size of the block\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\r\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\r\n\r\n  // set 'back' to itself at the end of block\r\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // perform insertion\r\n  var head = GETHEAD(root, fl, sl);\r\n  block.prev = null;\r\n  block.next = head;\r\n  if (head) head.prev = block;\r\n  SETHEAD(root, fl, sl, block);\r\n\r\n  // update first and second level maps\r\n  root.flMap |= (1 << fl);\r\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\r\n}\r\n\r\n/** Removes a free block from internal lists. */\r\nfunction removeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // link previous and next free block\r\n  var prev = block.prev;\r\n  var next = block.next;\r\n  if (prev) prev.next = next;\r\n  if (next) next.prev = prev;\r\n\r\n  // update head if we are removing it\r\n  if (block == GETHEAD(root, fl, sl)) {\r\n    SETHEAD(root, fl, sl, next);\r\n\r\n    // clear second level map if head is empty now\r\n    if (!next) {\r\n      let slMap = GETSL(root, fl);\r\n      SETSL(root, fl, slMap &= ~(1 << sl));\r\n\r\n      // clear first level map if second level is empty now\r\n      if (!slMap) root.flMap &= ~(1 << fl);\r\n    }\r\n  }\r\n  // note: does not alter left/back because it is likely that splitting\r\n  // is performed afterwards, invalidating those changes. so, the caller\r\n  // must perform those updates.\r\n}\r\n\r\n/** Searches for a free block of at least the specified size. */\r\nfunction searchBlock(root: Root, size: usize): Block | null {\r\n  // size was already asserted by caller\r\n\r\n  // mapping_search\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    const invRound = inv - SL_BITS;\r\n    let requestSize = size < halfMaxSize\r\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\r\n      : size;\r\n    fl = inv - clz<usize>(requestSize);\r\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // search second level\r\n  var slMap = GETSL(root, fl) & (~0 << sl);\r\n  var head: Block | null = null;\r\n  if (!slMap) {\r\n    // search next larger first level\r\n    let flMap = root.flMap & (~0 << (fl + 1));\r\n    if (!flMap) {\r\n      head = null;\r\n    } else {\r\n      fl = ctz<usize>(flMap);\r\n      slMap = GETSL(root, fl);\r\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\r\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n    }\r\n  } else {\r\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n  }\r\n  return head;\r\n}\r\n\r\n/** Prepares the specified block before (re-)use, possibly splitting it. */\r\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\r\n  // size was already asserted by caller\r\n\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\r\n\r\n  // split if the block can hold another MINSIZE block incl. overhead\r\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\r\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\r\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\r\n\r\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\r\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\r\n    insertBlock(root, spare); // also sets 'back'\r\n\r\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\r\n  } else {\r\n    block.mmInfo = blockInfo & ~FREE;\r\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\r\n  }\r\n}\r\n\r\n/** Adds more memory to the pool. */\r\nfunction addMemory(root: Root, start: usize, end: usize): bool {\r\n  if (DEBUG) {\r\n    assert(\r\n      start <= end &&       // must be valid\r\n      !(start & AL_MASK) && // must be aligned\r\n      !(end & AL_MASK)      // must be aligned\r\n    );\r\n  }\r\n\r\n  var tail = GETTAIL(root);\r\n  var tailInfo: usize = 0;\r\n  if (tail) { // more memory\r\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\r\n\r\n    // merge with current tail if adjacent\r\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\r\n      start -= BLOCK_OVERHEAD;\r\n      tailInfo = tail.mmInfo;\r\n    } else {\r\n      // We don't do this, but a user might `memory.grow` manually\r\n      // leading to non-adjacent pages managed by TLSF.\r\n    }\r\n\r\n  } else if (DEBUG) { // first memory\r\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\r\n  }\r\n\r\n  // check if size is large enough for a free block and the tail block\r\n  var size = end - start;\r\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\r\n    return false;\r\n  }\r\n\r\n  // left size is total minus its own and the zero-length tail's header\r\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\r\n  var left = changetype<Block>(start);\r\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\r\n  left.prev = null;\r\n  left.next = null;\r\n\r\n  // tail is a zero-length used block\r\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\r\n  tail.mmInfo = 0 | LEFTFREE;\r\n  SETTAIL(root, tail);\r\n\r\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\r\n\r\n  return true;\r\n}\r\n\r\n/** Grows memory to fit at least another block of the specified size. */\r\nfunction growMemory(root: Root, size: usize): void {\r\n  // Here, both rounding performed in searchBlock ...\r\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\r\n  if (size < halfMaxSize) { // don't round last fl\r\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\r\n    size += (1 << (invRound - clz<usize>(size))) - 1;\r\n  }\r\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\r\n  // to merge with the tail block, that's one time, otherwise it's two times.\r\n  var pagesBefore = memory.size();\r\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\r\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n  if (memory.grow(pagesWanted) < 0) {\r\n    if (memory.grow(pagesNeeded) < 0) unreachable();\r\n  }\r\n  var pagesAfter = memory.size();\r\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n}\r\n\r\n/** Prepares and checks an allocation size. */\r\nfunction prepareSize(size: usize): usize {\r\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\r\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\r\n}\r\n\r\n/** Initilizes the root structure. */\r\nexport function initializeRoot(): void {\r\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n  var root = changetype<Root>(rootOffset);\r\n  root.flMap = 0;\r\n  SETTAIL(root, changetype<Block>(0));\r\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n    SETSL(root, fl, 0);\r\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n      SETHEAD(root, fl, sl, null);\r\n    }\r\n  }\r\n  addMemory(root, (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\r\n  ROOT = root;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar collectLock: bool = false;\r\n\r\n/** Allocates a block of the specified size. */\r\nexport function allocateBlock(root: Root, size: usize): Block {\r\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\r\n  var payloadSize = prepareSize(size);\r\n  var block = searchBlock(root, payloadSize);\r\n  if (!block) {\r\n    if (gc.auto) {\r\n      if (DEBUG) collectLock = true;\r\n      __collect();\r\n      if (DEBUG) collectLock = false;\r\n      block = searchBlock(root, payloadSize);\r\n      if (!block) {\r\n        growMemory(root, payloadSize);\r\n        block = <Block>searchBlock(root, payloadSize);\r\n        if (DEBUG) assert(block); // must be found now\r\n      }\r\n    } else {\r\n      growMemory(root, payloadSize);\r\n      block = <Block>searchBlock(root, payloadSize);\r\n      if (DEBUG) assert(block); // must be found now\r\n    }\r\n  }\r\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\r\n  block.gcInfo = 0; // RC=0\r\n  // block.rtId = 0; // set by the caller (__alloc)\r\n  block.rtSize = size;\r\n  removeBlock(root, <Block>block);\r\n  prepareBlock(root, <Block>block, payloadSize);\r\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\r\n  return <Block>block;\r\n}\r\n\r\n/** Reallocates a block to the specified size. */\r\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) {\r\n    assert(\r\n      !(blockInfo & FREE) &&           // must be used\r\n      !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\r\n    );\r\n  }\r\n\r\n  // possibly split and update runtime size if it still fits\r\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\r\n    prepareBlock(root, block, payloadSize);\r\n    block.rtSize = size;\r\n    return block;\r\n  }\r\n\r\n  // merge with right free block if merger is large enough\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n  if (rightInfo & FREE) {\r\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (mergeSize >= payloadSize) {\r\n      removeBlock(root, right);\r\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\r\n      // is immediately split though. does this trigger any assertions / issues?\r\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\r\n      block.rtSize = size;\r\n      prepareBlock(root, block, payloadSize);\r\n      return block;\r\n    }\r\n  }\r\n\r\n  // otherwise move the block\r\n  var newBlock = allocateBlock(root, size);\r\n  newBlock.rtId = block.rtId;\r\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\r\n  block.mmInfo = blockInfo | FREE;\r\n  insertBlock(root, block);\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n  return newBlock;\r\n}\r\n\r\n/** Frees a block. */\r\nexport function freeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  assert(!(blockInfo & FREE)); // must be used (user might call through to this)\r\n  block.mmInfo = blockInfo | FREE;\r\n  insertBlock(root, block);\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __alloc(size: usize, id: u32): usize {\r\n  var root = ROOT;\r\n  if (!root) {\r\n    initializeRoot();\r\n    root = ROOT;\r\n  }\r\n  var block = allocateBlock(root, size);\r\n  block.rtId = id;\r\n  return changetype<usize>(block) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __realloc(ref: usize, size: usize): usize {\r\n  if (DEBUG) assert(ROOT); // must be initialized\r\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\r\n  return changetype<usize>(reallocateBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD), size)) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __free(ref: usize): void {\r\n  if (DEBUG) assert(ROOT); // must be initialized\r\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\r\n  freeBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD));\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\n/** Garbage collector interface. */\r\nexport namespace gc {\r\n\r\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\r\n  export var auto: bool = true;\r\n\r\n  /** Performs a full garbage collection cycle. */\r\n  export function collect(): void {\r\n    __collect();\r\n  }\r\n}\r\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\r\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\r\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare const __rtti_base: usize;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_globals(cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_members(ref: usize, cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __typeinfo(id: u32): TypeinfoFlags {\r\n  var ptr = __rtti_base;\r\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\r\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\r\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\r\n  var ptr = __rtti_base;\r\n  if (id <= load<u32>(ptr)) {\r\n    do if (id == superId) return true;\r\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\r\n  }\r\n  return false;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\r\n  var array = __alloc(offsetof<i32[]>(), id);\r\n  var bufferSize = <usize>length << alignLog2;\r\n  var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\r\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"buffer\"));\r\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"dataStart\"));\r\n  store<u32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\r\n  store<i32>(changetype<usize>(array), length, offsetof<i32[]>(\"length_\"));\r\n  if (data) memory.copy(buffer, data, bufferSize);\r\n  return array;\r\n}\r\n\r\n// These are provided by the respective implementation, included as another entry file by asc:\r\n\r\n// @builtin @unsafe\r\n// export declare function __alloc(size: usize, id: u32): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __realloc(ref: usize, size: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __free(ref: usize): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __retain(ref: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __release(ref: usize): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __collect(): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __visit(ref: usize, cookie: u32): void;\r\n","// Common error messages for use accross the standard library. Keeping error messages compact\r\n// and reusing them where possible ensures minimal static data in binaries.\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_EMPTYARRAY: string = \"Array is empty\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\r\n","import { memcmp, memmove, memset } from \"./util/memory\";\r\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\r\n\r\n/** Memory manager interface. */\r\nexport namespace memory {\r\n\r\n  /** Gets the size of the memory in pages. */\r\n  // @ts-ignore: decorator\r\n  @builtin\r\n  export declare function size(): i32;\r\n\r\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export declare function grow(pages: i32): i32;\r\n\r\n  /** Fills a section in memory with the specified byte value. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function fill(dst: usize, c: u8, n: usize): void {\r\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Copies a section of memory to another. Has move semantics. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function copy(dst: usize, src: usize, n: usize): void {\r\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Initializes a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Drops a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function drop(segmentIndex: u32): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Repeats a section of memory at a specific address. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\r\n    var index: usize = 0;\r\n    var total = srcLength * count;\r\n    while (index < total) {\r\n      memory.copy(dst + index, src, srcLength);\r\n      index += srcLength;\r\n    }\r\n  }\r\n\r\n  /** Compares a section of memory to another. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\r\n    return memcmp(vl, vr, n);\r\n  }\r\n}\r\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    let w: u32, x: u32;\r\n\r\n    // copy 1 byte each until src is aligned to 4 bytes\r\n    while (n && (src & 3)) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      n--;\r\n    }\r\n\r\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n    if ((dest & 3) == 0) {\r\n      while (n >= 16) {\r\n        store<u32>(dest     , load<u32>(src     ));\r\n        store<u32>(dest +  4, load<u32>(src +  4));\r\n        store<u32>(dest +  8, load<u32>(src +  8));\r\n        store<u32>(dest + 12, load<u32>(src + 12));\r\n        src += 16; dest += 16; n -= 16;\r\n      }\r\n      if (n & 8) {\r\n        store<u32>(dest    , load<u32>(src    ));\r\n        store<u32>(dest + 4, load<u32>(src + 4));\r\n        dest += 8; src += 8;\r\n      }\r\n      if (n & 4) {\r\n        store<u32>(dest, load<u32>(src));\r\n        dest += 4; src += 4;\r\n      }\r\n      if (n & 2) { // drop to 2 bytes each\r\n        store<u16>(dest, load<u16>(src));\r\n        dest += 2; src += 2;\r\n      }\r\n      if (n & 1) { // drop to 1 byte\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      return;\r\n    }\r\n\r\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n    if (n >= 32) {\r\n      switch (dest & 3) {\r\n        // known to be != 0\r\n        case 1: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 3;\r\n          while (n >= 17) {\r\n            x = load<u32>(src + 1);\r\n            store<u32>(dest, w >> 24 | x << 8);\r\n            w = load<u32>(src + 5);\r\n            store<u32>(dest + 4, x >> 24 | w << 8);\r\n            x = load<u32>(src + 9);\r\n            store<u32>(dest + 8, w >> 24 | x << 8);\r\n            w = load<u32>(src + 13);\r\n            store<u32>(dest + 12, x >> 24 | w << 8);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n        case 2: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 2;\r\n          while (n >= 18) {\r\n            x = load<u32>(src + 2);\r\n            store<u32>(dest, w >> 16 | x << 16);\r\n            w = load<u32>(src + 6);\r\n            store<u32>(dest + 4, x >> 16 | w << 16);\r\n            x = load<u32>(src + 10);\r\n            store<u32>(dest + 8, w >> 16 | x << 16);\r\n            w = load<u32>(src + 14);\r\n            store<u32>(dest + 12, x >> 16 | w << 16);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n        case 3: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 1;\r\n          while (n >= 19) {\r\n            x = load<u32>(src + 3);\r\n            store<u32>(dest, w >> 8 | x << 24);\r\n            w = load<u32>(src + 7);\r\n            store<u32>(dest + 4, x >> 8 | w << 24);\r\n            x = load<u32>(src + 11);\r\n            store<u32>(dest + 8, w >> 8 | x << 24);\r\n            w = load<u32>(src + 15);\r\n            store<u32>(dest + 12, x >> 8 | w << 24);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // copy remaining bytes one by one\r\n    if (n & 16) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 8) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 4) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 2) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 1) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (src + n <= dest || dest + n <= src) {\r\n      memcpy(dest, src, n);\r\n      return;\r\n    }\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, c);\r\n      --n;\r\n    }\r\n  } else {\r\n    // fill head and tail with minimal branching\r\n    if (!n) return;\r\n    store<u8>(dest, c);\r\n    store<u8>(dest + n - 1, c);\r\n    if (n <= 2) return;\r\n\r\n    store<u8>(dest + 1, c);\r\n    store<u8>(dest + 2, c);\r\n    store<u8>(dest + n - 2, c);\r\n    store<u8>(dest + n - 3, c);\r\n    if (n <= 6) return;\r\n    store<u8>(dest + 3, c);\r\n    store<u8>(dest + n - 4, c);\r\n    if (n <= 8) return;\r\n\r\n    // advance pointer to align it at 4-byte boundary\r\n    let k: usize = -dest & 3;\r\n    dest += k;\r\n    n -= k;\r\n    n &= -4;\r\n\r\n    let c32: u32 = <u32>-1 / 255 * c;\r\n\r\n    // fill head/tail up to 28 bytes each in preparation\r\n    store<u32>(dest, c32);\r\n    store<u32>(dest + n - 4, c32);\r\n    if (n <= 8) return;\r\n    store<u32>(dest + 4, c32);\r\n    store<u32>(dest + 8, c32);\r\n    store<u32>(dest + n - 12, c32);\r\n    store<u32>(dest + n - 8, c32);\r\n    if (n <= 24) return;\r\n    store<u32>(dest + 12, c32);\r\n    store<u32>(dest + 16, c32);\r\n    store<u32>(dest + 20, c32);\r\n    store<u32>(dest + 24, c32);\r\n    store<u32>(dest + n - 28, c32);\r\n    store<u32>(dest + n - 24, c32);\r\n    store<u32>(dest + n - 20, c32);\r\n    store<u32>(dest + n - 16, c32);\r\n\r\n    // align to a multiple of 8\r\n    k = 24 + (dest & 4);\r\n    dest += k;\r\n    n -= k;\r\n\r\n    // copy 32 bytes each\r\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n    while (n >= 32) {\r\n      store<u64>(dest, c64);\r\n      store<u64>(dest + 8, c64);\r\n      store<u64>(dest + 16, c64);\r\n      store<u64>(dest + 24, c64);\r\n      n -= 32;\r\n      dest += 32;\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\r\n  if (vl == vr) return 0;\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if ((vl & 7) == (vr & 7)) {\r\n      while (vl & 7) {\r\n        if (!n) return 0;\r\n        let a = <i32>load<u8>(vl);\r\n        let b = <i32>load<u8>(vr);\r\n        if (a != b) return a - b;\r\n        n--; vl++; vr++;\r\n      }\r\n      while (n >= 8) {\r\n        if (load<u64>(vl) != load<u64>(vr)) break;\r\n        vl += 8;\r\n        vr += 8;\r\n        n  -= 8;\r\n      }\r\n    }\r\n  }\r\n  while (n--) {\r\n    let a = <i32>load<u8>(vl);\r\n    let b = <i32>load<u8>(vr);\r\n    if (a != b) return a - b;\r\n    vl++; vr++;\r\n  }\r\n  return 0;\r\n}\r\n","//\r\n// Compile opentypejs.PathCommand into shapes data \r\n// which is ready to map to library dependent struct \r\n// e.g. `BABYLON.Vector3(x, 0, -y)` \r\n//\r\n\r\n// # Sample Output\r\n// (Array of shapes) \r\n// [\r\n//   [ fill, hole, hole ]  # \"fill\" has 2 \"holes\" inside\r\n//   [ fill ]              # \"fill\" has 0 \"holes\"\r\n// ] \r\n// where\r\n//   fill = [[x, y], [x, y], ...]\r\n//   hole = ditto\r\n\r\n// # Note\r\n// + Memory Base occupies 16384 bytes \r\n//   roughly contain 250 \"flatten\" PathCommands for 'C' \r\n\r\n// # Flatten PathCommands in Linear Memory Structure\r\n// | Command | Structure\r\n// |---------|---------- \r\n// | M       | u8, f64, f64\r\n// | L       | u8, f64, f64\r\n// | Q       | u8, f64, f64, f64, f64, f64, f64\r\n// | C       | u8, f64, f64, f64, f64, f64, f64, f64, f64\r\n// | Z       | u8\r\n\r\n\r\ntype Vertex = Array<f64>;\r\ntype Polygon = Array<Vertex>;\r\ntype Result = Array<Array<Polygon>>;\r\n\r\nconst SZ = 8; // f64 sz in byte\r\n\r\n\r\n\r\n//\r\n// \"bring-in\" fns (just some debug utilities) \r\n// Pipe wasm stuff to js console\r\n// Comment out when build\r\n//\r\n\r\n// export declare function inspectPolygons(msg: string, x: Array<Polygon>): void;\r\n// export declare function inspectNumber(msg: string, x: number): void;\r\n\r\n\r\n\r\n//\r\n// Compile loadedIn opentype PathCommand data (already in memory base sector) \r\n// {bytesUsed} flatten commands bytes used (must < --memoryBase value)\r\n// {fmt} outlineFormat; 1:'cff' non1:'truetype'\r\n// {ppc} pointPerCurve; 0~255\r\n// {eps} dedupEpsilon; ideal values 0.001, 0.002, ...\r\n//\r\n\r\nexport function compile(bytesUsed: usize, fmt: u8, ppc: u8, eps: f64): Result {\r\n\r\n  ppc += 2;\r\n\r\n  let polygons: Array<Polygon> = [];\r\n\r\n  let i: usize = 0;\r\n  let iP: usize = 0;\r\n  let cmd: u8;\r\n  let x0: f64, y0: f64;\r\n  let x1: f64, y1: f64;\r\n  let x2: f64, y2: f64;\r\n  let x: f64, y: f64;\r\n\r\n  while (i < bytesUsed) {\r\n    cmd = load<u8>(i);\r\n    i += 1;\r\n    if (cmd == 77) { // 'M'\r\n      x = load<f64>(i);\r\n      i += SZ;\r\n      y = load<f64>(i);\r\n      i += SZ;\r\n      polygons[iP] = [[x, y]];\r\n      continue;\r\n    }\r\n    if (cmd == 76) { // L\r\n      x = load<f64>(i);\r\n      i += SZ;\r\n      y = load<f64>(i);\r\n      i += SZ;\r\n      polygons[iP].push([x, y]);\r\n      continue;\r\n    }\r\n    if (cmd == 81) { // 'Q'\r\n      x0 = load<f64>(i);\r\n      i += SZ;\r\n      y0 = load<f64>(i);\r\n      i += SZ;\r\n      x1 = load<f64>(i);\r\n      i += SZ;\r\n      y1 = load<f64>(i);\r\n      i += SZ;\r\n      x = load<f64>(i);\r\n      i += SZ;\r\n      y = load<f64>(i);\r\n      i += SZ;\r\n      let vs = interpQ(\r\n        [x0, y0],\r\n        [x1, y1],\r\n        [x, y],\r\n        ppc\r\n      );\r\n      for (let k = 1; k < vs.length; ++k) {\r\n        polygons[iP].push(vs[k]);\r\n      }\r\n      continue;\r\n    }\r\n    if (cmd == 67) { // 'C'\r\n      x0 = load<f64>(i);\r\n      i += SZ;\r\n      y0 = load<f64>(i);\r\n      i += SZ;\r\n      x1 = load<f64>(i);\r\n      i += SZ;\r\n      y1 = load<f64>(i);\r\n      i += SZ;\r\n      x2 = load<f64>(i);\r\n      i += SZ;\r\n      y2 = load<f64>(i);\r\n      i += SZ;\r\n      x = load<f64>(i);\r\n      i += SZ;\r\n      y = load<f64>(i);\r\n      i += SZ;\r\n      let vs = interpC(\r\n        [x0, y0],\r\n        [x1, y1],\r\n        [x2, y2],\r\n        [x, y],\r\n        ppc\r\n      );\r\n      for (let k = 1; k < vs.length; ++k) {\r\n        polygons[iP].push(vs[k]);\r\n      }\r\n      continue;\r\n    }\r\n    if (cmd == 90) { // 'Z'\r\n      polygons[iP] = dedup(polygons[iP], eps);\r\n      iP += 1;\r\n      continue;\r\n    }\r\n  }\r\n\r\n  //\r\n  // Determine fill/hole\r\n  // cff : oddeven (cw+1, ccw-1)\r\n  //\r\n\r\n  const fills: Array<Polygon> = [];\r\n  const holes: Array<Polygon> = [];\r\n  let polygon: Polygon;\r\n  {\r\n    for (let i = 0; i < polygons.length; ++i) {\r\n      polygon = polygons[i];\r\n      let isHole: bool;\r\n      if (fmt == 1) { // cff\r\n        isHole = isHole_oddeven(polygon, polygons);\r\n      }\r\n      else { // truetype or unknown\r\n        isHole = isHole_nonzero(polygon, polygons);\r\n      }\r\n      if (isHole) {\r\n        holes.push(polygon);\r\n      }\r\n      else {\r\n        fills.push(polygon);\r\n      }\r\n    }\r\n  }\r\n\r\n  // inspectPolygons('polygons', polygons);\r\n  // inspectPolygons('filles', fills);\r\n  // inspectPolygons('holes', holes);\r\n  // inspectNumber('polygon count', polygons.length);\r\n\r\n  const result: Array<Array<Polygon>> = [];\r\n  linkUp(fills, holes, result);\r\n  return result;\r\n}\r\n\r\n\r\n//\r\n// Linkup\r\n//\r\n\r\nfunction linkUp(\r\n  fills: Array<Polygon>,\r\n  holes: Array<Polygon>,\r\n  result: Array<Array<Polygon>>\r\n): Result {\r\n  let hole: Polygon;\r\n  let fill: Polygon;\r\n  for (let i = 0; i < fills.length; ++i) {\r\n    fill = fills[i];\r\n    const $hs: Array<Polygon> = []; // hole stash\r\n    for (let j = 0; j < holes.length; ++j) {\r\n      hole = holes[j];\r\n      if (!isPolygonInsidePolygon(hole, fill)) {\r\n        continue;\r\n      }\r\n      let isInside = false;\r\n      for (let k = 0; k < $hs.length; ++k) {\r\n        const $h = $hs[k];\r\n        if (isPolygonInsidePolygon(hole, $h)) {\r\n          isInside = true;\r\n          break;\r\n        }\r\n        if (isPolygonInsidePolygon($h, hole)) {\r\n          $hs.splice($hs.indexOf($h), 1);\r\n          // Dont shortcurcuit; holes in stach\r\n          // maybe also inside current testing hole.\r\n        }\r\n      }\r\n      if (!isInside) {\r\n        $hs.push(hole);\r\n      }\r\n    }\r\n    let shape: Array<Polygon> = [fill];\r\n    for (let i = 0; i < $hs.length; ++i) {\r\n      shape.push($hs[i]);\r\n    }\r\n    result.push(shape);\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n\r\n//\r\n// Dedup nearby vertices\r\n//\r\n\r\nfunction dedup(\r\n  vs: Polygon,\r\n  eps: f64\r\n): Polygon {\r\n  const result: Polygon = [\r\n    vs[0]\r\n  ];\r\n  let $len: usize;\r\n  if (isVertexEqual(vs[vs.length - 1], vs[0], eps)) {\r\n    $len = vs.length - 1;\r\n  }\r\n  else {\r\n    $len = vs.length;\r\n  }\r\n  let i = usize(1);\r\n  let $v: Vertex;\r\n  let $1 = vs[0];\r\n  while (i < $len) {\r\n    $v = vs[i];\r\n    if (!isVertexEqual($v, $1, eps)) {\r\n      result.push($v);\r\n      $1 = $v;\r\n    }\r\n    ++i;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction isVertexEqual(p0: Vertex, p1: Vertex, eps: f64): bool {\r\n  return p0[0] == p1[0] && p0[1] == p1[1] // fast check\r\n    || (p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2 <= eps ** 2;\r\n}\r\n\r\n\r\n\r\n//\r\n// Interpolate 'Q' command\r\n// \r\n\r\nfunction interpQ(\r\n  p0: Vertex,\r\n  p1: Vertex,\r\n  p2: Vertex,\r\n  n: u8\r\n): Array<Vertex> {\r\n  const result: Array<Vertex> = [];\r\n  let $0 = NaN;\r\n  let $1 = NaN;\r\n  let $2 = NaN;\r\n  let $$ = NaN;\r\n  let t: f64 = 0;\r\n  let i: u8 = 0;\r\n  for (; i < n; ++i) {\r\n    t = f64(f64(i) / (n - 1.0));\r\n    $0 = ($$ = 1.0 - t) ** 2.0;\r\n    $1 = 2.0 * $$ * t;\r\n    $2 = t ** 2.0;\r\n    result.push([\r\n      f64($0 * p0[0] + $1 * p1[0] + $2 * p2[0]),\r\n      f64($0 * p0[1] + $1 * p1[1] + $2 * p2[1])\r\n    ]);\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n\r\n//\r\n// Interpolate 'C' command\r\n//\r\n\r\nfunction interpC(p0: Vertex, p1: Vertex, p2: Vertex, p3: Vertex, n: u8): Array<Vertex> {\r\n  const result: Array<Vertex> = [];\r\n  let $0 = NaN;\r\n  let $1 = NaN;\r\n  let $2 = NaN;\r\n  let $3 = NaN;\r\n  let $4 = NaN;\r\n  let $5 = NaN;\r\n  let $6 = NaN;\r\n  let i: u8 = 0;\r\n  let t: f64 = 0;\r\n  for (; i < n; ++i) {\r\n    t = f64(f64(i) / (n - 1.0));\r\n    $0 = 1.0 - t;\r\n    $1 = $0 ** 2;             // (1-t) ^2\r\n    $2 = $1 * $0;             // (1-t) ^3 ... coeff#0\r\n    $3 = t ** 2.0;            // t ^2\r\n    $4 = $3 * t;              // t ^3      .. coeff#3\r\n    $5 = 3.0 * $1 * t;        //          ... coeff#1\r\n    $6 = 3.0 * $0 * $3;       //          ... coeff#2\r\n    result.push([\r\n      f64($2 * p0[0] + $5 * p1[0] + $6 * p2[0] + $4 * p3[0]),\r\n      f64($2 * p0[1] + $5 * p1[1] + $6 * p2[1] + $4 * p3[1])\r\n    ]);\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n\r\n//\r\n// Detect hole; by oddeven fillrule (even=hole) \r\n// (cff outline)\r\n//\r\n\r\nfunction isHole_oddeven(target: Polygon, polygons: Polygon[]): bool {\r\n  const p0 = pickAPoint(target);\r\n  const $p1: Vertex = [100, p0[1]];\r\n  let c = 0;\r\n  let $polygon: Polygon;\r\n  let $v0: Vertex;\r\n  let $v1: Vertex;\r\n  for (let i = 0; i < polygons.length; ++i) {\r\n    $polygon = polygons[i];\r\n    for (let j = 0; j < $polygon.length; ++j) {\r\n      $v0 = $polygon[j];\r\n      $v1 = $polygon[j == $polygon.length - 1 ? 0 : j + 1];\r\n      if (isLinesIntersect(p0, $p1, $v0, $v1)) {\r\n        ++c;\r\n      }\r\n    }\r\n  }\r\n  return c % 2 === 0;\r\n}\r\n\r\n\r\n\r\n//\r\n// Detect hole; by nonzero fillrule (0=hole)\r\n// (truetype outline)\r\n//\r\n\r\nfunction isHole_nonzero(\r\n  target: Polygon,\r\n  polygons: Array<Polygon>\r\n): bool {\r\n  const p0: Vertex = pickAPoint(target);\r\n  const $p1: Vertex = [100, p0[1]];\r\n  let $v1: Vertex;\r\n  let $v0: Vertex;\r\n  let c = 0;\r\n  let $polygon: Polygon;\r\n  for (let i = 0; i < polygons.length; ++i) {\r\n    $polygon = polygons[i];\r\n    for (let j = 0; j < $polygon.length; ++j) {\r\n      $v0 = $polygon[j];\r\n      $v1 = $polygon[j == $polygon.length - 1 ? 0 : j + 1];\r\n      if (isLinesIntersect(p0, $p1, $v0, $v1)) {\r\n        c += windingOfTwoLines(p0, $v0, $v1);\r\n      }\r\n    }\r\n  }\r\n  return c % 2 === 0;\r\n}\r\n\r\n\r\n\r\n//\r\n// Pick a point in polygon\r\n//\r\n\r\nfunction pickAPoint(\r\n  vs: Polygon\r\n): Vertex {\r\n  let max = vs[0][0];\r\n  let i = 0;\r\n  let j = 1;\r\n  let $len = vs.length;\r\n  let $v: Vertex = vs[0];\r\n  while (j < $len) {\r\n    $v = vs[j];\r\n    if ($v[0] > max) {\r\n      max = $v[0];\r\n      i = j;\r\n    }\r\n    ++j;\r\n  }\r\n  const curr = vs[i];\r\n  const prev = vs[i ? i - 1 : $len - 1];\r\n  const next = vs[(i + 1) % $len];\r\n  // $1: (next-curr)/|next-curr| * epsilon + curr -> tinystep from curr to next\r\n  // $2: (prev-curr)/|prev-curr| * epsilon + curr -> tinystep from curr to prev \r\n  // then ($1 + $2 + curr)/3 ~= tri centroid \r\n  const $1 = tinystep(curr, next, 0.001);\r\n  const $2 = tinystep(curr, prev, 0.001);\r\n  return [\r\n    ($1[0] + $2[0] + curr[0]) / 3,\r\n    ($1[1] + $2[1] + curr[1]) / 3\r\n  ];\r\n}\r\n\r\n\r\n\r\n//\r\n// Find a point from v0 to v1 && very close-to v0 \r\n//\r\n\r\nfunction tinystep(\r\n  v0: Vertex,\r\n  v1: Vertex,\r\n  e: f64\r\n): Vertex {\r\n  const d = ((v1[1] - v0[1]) ** 2 + (v1[0] - v0[0]) ** 2) ** 0.5;\r\n  return [\r\n    f64((v1[0] - v0[0]) / d * e + v0[0]),\r\n    f64((v1[1] - v0[1]) / d * e + v0[1])\r\n  ];\r\n}\r\n\r\n\r\n\r\n//\r\n// is Line A intersects Line B\r\n//\r\n\r\nfunction isLinesIntersect(\r\n  a: Vertex, // line seg A endpoint\r\n  b: Vertex, // line seg A endpoint\r\n  c: Vertex, // line seg B endpoint\r\n  d: Vertex  // line seg B endpoint\r\n): bool {\r\n  return windingOfTwoLines(a, b, c) !== windingOfTwoLines(a, b, d)\r\n    && windingOfTwoLines(c, d, a) !== windingOfTwoLines(c, d, b);\r\n}\r\n\r\n\r\n\r\n//\r\n// Winding from ab to ac\r\n//\r\n\r\nfunction windingOfTwoLines(\r\n  a: Vertex,\r\n  b: Vertex,\r\n  c: Vertex\r\n): i32 {\r\n  // (b - a) cross (c - a)\r\n  // ^^$1^^^       ^^$2^^^\r\n  // const $1x = b[0] - a[0];\r\n  // const $1y = b[1] - a[1];\r\n  // const $2x = c[0] - a[0];\r\n  // const $2y = c[1] - a[1];\r\n  // cross\r\n  // return $1x * $2y - $1y * $2x < 0 ? -1 : +1;\r\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) < 0 ? -1 : 1;\r\n}\r\n\r\n\r\n\r\n//\r\n// Is point inside polygon \r\n//\r\n\r\nfunction isPointInsidePolygon(\r\n  p: Vertex,\r\n  vs: Polygon\r\n): bool {\r\n  const $p1: Vertex = [100, p[1]];\r\n  let c = 0; // nonzero winding rule count\r\n  let $v1: Vertex;\r\n  let $v0: Vertex;\r\n  for (let i = 0; i < vs.length; ++i) {\r\n    $v0 = vs[i];\r\n    $v1 = vs[i == vs.length - 1 ? 0 : i + 1];\r\n    if (isLinesIntersect(p, $p1, $v0, $v1)) {\r\n      c += windingOfTwoLines(p, $v0, $v1);\r\n    }\r\n  }\r\n  return c % 2 != 0; // nonzero = inside \r\n}\r\n\r\n\r\n\r\n//\r\n// BBox of polygon\r\n//\r\n\r\nfunction boundingBoxOf(polygon: Polygon): Array<f64> {\r\n  let xMin = Infinity;\r\n  let yMin = Infinity;\r\n  let xMax = -Infinity;\r\n  let yMax = -Infinity;\r\n  let $v: Vertex;\r\n  for (let i = 0; i < polygon.length; ++i) {\r\n    $v = polygon[i];\r\n    if ($v[0] < xMin) { xMin = $v[0] }\r\n    else if ($v[0] > xMax) { xMax = $v[0] }\r\n    if ($v[1] < yMin) { yMin = $v[1] }\r\n    else if ($v[1] > yMax) { yMax = $v[1] }\r\n  }\r\n  return [xMin, yMin, xMax, yMax];\r\n}\r\n\r\n\r\n\r\n//\r\n// Is polygon A inside polygon B\r\n// (for testing is \"hole\" in \"fill\", is \"hole\" in \"hole\") \r\n//\r\n\r\nfunction isPolygonInsidePolygon(\r\n  A: Polygon,\r\n  B: Polygon\r\n): bool {\r\n  //\r\n  // ------ boundingbox fast check\r\n  //\r\n  let bboxA = boundingBoxOf(A);\r\n  let bboxB = boundingBoxOf(B);\r\n  if (bboxA[0] < bboxB[0] && bboxA[2] < bboxB[0]\r\n    || bboxA[0] > bboxB[2] && bboxA[2] > bboxB[2]\r\n    || bboxA[1] < bboxB[1] && bboxA[3] < bboxB[1]\r\n    || bboxA[1] > bboxB[3] && bboxA[3] > bboxB[3]\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  //\r\n  // true if A is not touching B && A has a point inside B\r\n  //\r\n\r\n  for (let iA = 0; iA < A.length; ++iA) {\r\n    let $vA0 = A[iA];\r\n    let $vA1 = A[iA == A.length - 1 ? 0 : iA + 1];\r\n    for (let iB = 0; iB < B.length; ++iB) {\r\n      let $vB0 = B[iB];\r\n      let $vB1 = B[iB == B.length - 1 ? 0 : iB + 1];\r\n      if (isLinesIntersect($vA0, $vA1, $vB0, $vB1)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return isPointInsidePolygon(A[0], B);\r\n}\r\n\r\n\r\n\r\n\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\r\nimport { COMPARATOR, SORT } from \"./util/sort\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\r\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\r\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\r\n\r\n/** Ensures that the given array has _at least_ the specified backing size. */\r\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\r\n  var oldCapacity = changetype<ArrayBufferView>(array).byteLength;\r\n  if (minSize > <usize>oldCapacity >>> alignLog2) {\r\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\r\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\r\n    let newCapacity = minSize << alignLog2;\r\n    let newData = __realloc(oldData, newCapacity);\r\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\r\n    if (newData !== oldData) { // oldData has been free'd\r\n      store<usize>(array, __retain(newData), offsetof<ArrayBufferView>(\"buffer\"));\r\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\r\n    }\r\n    store<u32>(array, newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\r\n  }\r\n}\r\n\r\nexport class Array<T> extends ArrayBufferView {\r\n  [key: number]: T;\r\n\r\n  // Implementing ArrayBufferView isn't strictly necessary here but is done to allow glue code\r\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\r\n  // `dataStart` (equals `data`) and `dataLength` (equals computed `data.byteLength`).\r\n\r\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\r\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\r\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\r\n\r\n  private length_: i32;\r\n\r\n  static isArray<U>(value: U): bool {\r\n    return builtin_isArray(value) && value !== null;\r\n  }\r\n\r\n  static create<T>(capacity: i32 = 0): Array<T> {\r\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\r\n    var array = new Array<T>(capacity);\r\n    array.length = 0;\r\n    return array;\r\n  }\r\n\r\n  constructor(length: i32 = 0) {\r\n    super(length, alignof<T>());\r\n    this.length_ = length;\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.length_;\r\n  }\r\n\r\n  set length(newLength: i32) {\r\n    var oldLength = this.length_;\r\n    if (isManaged<T>()) {\r\n      if (oldLength > newLength) { // release no longer used refs\r\n        let cur = (<usize>newLength << alignof<T>());\r\n        let end = (<usize>oldLength << alignof<T>());\r\n        do __release(load<usize>(cur));\r\n        while ((cur += sizeof<T>()) < end);\r\n      } else {\r\n        ensureSize(changetype<usize>(this), newLength, alignof<T>());\r\n      }\r\n    } else {\r\n      ensureSize(changetype<usize>(this), newLength, alignof<T>());\r\n    }\r\n    this.length_ = newLength;\r\n  }\r\n\r\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  @operator(\"[]\") private __get(index: i32): T {\r\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    var value = this.__unchecked_get(index);\r\n    if (isReference<T>()) {\r\n      if (!isNullable<T>()) {\r\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n\r\n  @unsafe @operator(\"{}\") private __unchecked_get(index: i32): T {\r\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\r\n  }\r\n\r\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\r\n    ensureSize(changetype<usize>(this), index + 1, alignof<T>());\r\n    this.__unchecked_set(index, value);\r\n    if (index >= this.length_) this.length_ = index + 1;\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\") private __unchecked_set(index: i32, value: T): void {\r\n    if (isManaged<T>()) {\r\n      let offset = this.dataStart + (<usize>index << alignof<T>());\r\n      let oldRef = load<usize>(offset);\r\n      if (changetype<usize>(value) != oldRef) {\r\n        store<usize>(offset, __retain(changetype<usize>(value)));\r\n        __release(oldRef);\r\n      }\r\n    } else {\r\n      store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\r\n    }\r\n  }\r\n\r\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\r\n    var dataStart = this.dataStart;\r\n    var length = this.length_;\r\n    start = start < 0 ? max(length + start, 0) : min(start, length);\r\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\r\n    if (isManaged<T>()) {\r\n      for (; start < end; ++start) {\r\n        let oldRef: usize = load<usize>(dataStart + (<usize>start << alignof<T>()));\r\n        if (changetype<usize>(value) != oldRef) {\r\n          store<usize>(dataStart + (<usize>start << alignof<T>()), __retain(changetype<usize>(value)));\r\n          __release(oldRef);\r\n        }\r\n      }\r\n    } else if (sizeof<T>() == 1) {\r\n      if (start < end) {\r\n        memory.fill(\r\n          dataStart + <usize>start,\r\n          u8(value),\r\n          <usize>(end - start)\r\n        );\r\n      }\r\n    } else {\r\n      for (; start < end; ++start) {\r\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  includes(value: T, fromIndex: i32 = 0): bool {\r\n    return this.indexOf(value, fromIndex) >= 0;\r\n  }\r\n\r\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\r\n    var length = this.length_;\r\n    if (length == 0 || fromIndex >= length) return -1;\r\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n    var dataStart = this.dataStart;\r\n    while (fromIndex < length) {\r\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\r\n      ++fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\r\n    var length = this.length_;\r\n    if (length == 0) return -1;\r\n    if (fromIndex < 0) fromIndex = length + fromIndex;\r\n    else if (fromIndex >= length) fromIndex = length - 1;\r\n    var dataStart = this.dataStart;\r\n    while (fromIndex >= 0) {\r\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\r\n      --fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  push(value: T): i32 {\r\n    var length = this.length_;\r\n    var newLength = length + 1;\r\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\r\n    if (isManaged<T>()) {\r\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), __retain(changetype<usize>(value)));\r\n    } else {\r\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\r\n    }\r\n    this.length_ = newLength;\r\n    return newLength;\r\n  }\r\n\r\n  concat(other: Array<T>): Array<T> {\r\n    var thisLen = this.length_;\r\n    var otherLen = select(0, other.length_, other === null);\r\n    var outLen = thisLen + otherLen;\r\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\r\n    var out = changetype<Array<T>>(__allocArray(outLen, alignof<T>(), idof<Array<T>>())); // retains\r\n    var outStart = out.dataStart;\r\n    var thisSize = <usize>thisLen << alignof<T>();\r\n    if (isManaged<T>()) {\r\n      let thisStart = this.dataStart;\r\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(thisStart + offset);\r\n        store<usize>(outStart + offset, __retain(ref));\r\n      }\r\n      outStart += thisSize;\r\n      let otherStart = other.dataStart;\r\n      let otherSize = <usize>otherLen << alignof<T>();\r\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(otherStart + offset);\r\n        store<usize>(outStart + offset, __retain(ref));\r\n      }\r\n    } else {\r\n      memory.copy(outStart, this.dataStart, thisSize);\r\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\r\n    }\r\n    return out;\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\r\n    var dataStart = this.dataStart;\r\n    var len = this.length_;\r\n\r\n        end   = min<i32>(end, len);\r\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\r\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\r\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\r\n    var count = min(last - from, len - to);\r\n\r\n    if (isManaged<T>()) {\r\n      if (from < to && to < (from + count)) { // right to left\r\n        from += count - 1;\r\n        to   += count - 1;\r\n        while (count) {\r\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\r\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\r\n          if (newRef != oldRef) {\r\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\r\n            __release(oldRef);\r\n          }\r\n          --from, --to, --count;\r\n        }\r\n      } else { // left to right\r\n        while (count) {\r\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\r\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\r\n          if (newRef != oldRef) {\r\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\r\n            __release(oldRef);\r\n          }\r\n          ++from, ++to, --count;\r\n        }\r\n      }\r\n    } else {\r\n      memory.copy( // is memmove\r\n        dataStart + (<usize>to << alignof<T>()),\r\n        dataStart + (<usize>from << alignof<T>()),\r\n        <usize>count << alignof<T>()\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  pop(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\r\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\r\n    this.length_ = length;\r\n    return element; // no need to retain -> is moved\r\n  }\r\n\r\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\r\n    }\r\n  }\r\n\r\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\r\n    var length = this.length_;\r\n    var out = changetype<Array<U>>(__allocArray(length, alignof<U>(), idof<Array<U>>())); // retains\r\n    var outStart = out.dataStart;\r\n    for (let index = 0; index < min(length, this.length_); ++index) {\r\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this); // retains\r\n      if (isManaged<U>()) {\r\n        store<usize>(outStart + (<usize>index << alignof<U>()), __retain(changetype<usize>(result)));\r\n      } else {\r\n        store<U>(outStart + (<usize>index << alignof<U>()), result);\r\n      }\r\n      // releases result\r\n    }\r\n    return out;\r\n  }\r\n\r\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\r\n    var result = changetype<Array<T>>(__allocArray(0, alignof<T>(), idof<Array<T>>())); // retains\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\r\n      if (fn(value, index, this)) result.push(value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  reduce<U>(\r\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  reduceRight<U>(\r\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    for (let index = this.length_ - 1; index >= 0; --index) {\r\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  shift(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\r\n    var base = this.dataStart;\r\n    var element = load<T>(base);\r\n    var lastIndex = length - 1;\r\n    memory.copy(\r\n      base,\r\n      base + sizeof<T>(),\r\n      <usize>lastIndex << alignof<T>()\r\n    );\r\n    store<T>(base + (<usize>lastIndex << alignof<T>()),\r\n      // @ts-ignore: cast\r\n      <T>null\r\n    );\r\n    this.length_ = lastIndex;\r\n    return element; // no need to retain -> is moved\r\n  }\r\n\r\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  unshift(value: T): i32 {\r\n    var newLength = this.length_ + 1;\r\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\r\n    var dataStart = this.dataStart;\r\n    memory.copy(\r\n      dataStart + sizeof<T>(),\r\n      dataStart,\r\n      <usize>(newLength - 1) << alignof<T>()\r\n    );\r\n    if (isManaged<T>()) {\r\n      store<usize>(dataStart, __retain(changetype<usize>(value)));\r\n    } else {\r\n      store<T>(dataStart, value);\r\n    }\r\n    this.length_ = newLength;\r\n    return newLength;\r\n  }\r\n\r\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length = this.length_;\r\n    start = start < 0 ? max(start + length, 0) : min(start, length);\r\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\r\n    length = max(end - start, 0);\r\n    var slice = changetype<Array<T>>(__allocArray(length, alignof<T>(), idof<Array<T>>())); // retains\r\n    var sliceBase = slice.dataStart;\r\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\r\n    if (isManaged<T>()) {\r\n      let off = <usize>0;\r\n      let end = <usize>length << alignof<usize>();\r\n      while (off < end) {\r\n        let ref = load<usize>(thisBase + off);\r\n        store<usize>(sliceBase + off, __retain(ref));\r\n        off += sizeof<usize>();\r\n      }\r\n    } else {\r\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\r\n    }\r\n    return slice;\r\n  }\r\n\r\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length  = this.length_;\r\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\r\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\r\n    var result = changetype<Array<T>>(__allocArray(deleteCount, alignof<T>(), idof<Array<T>>())); // retains\r\n    var resultStart = result.dataStart;\r\n    var thisStart = this.dataStart;\r\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\r\n    if (isManaged<T>()) {\r\n      for (let i = 0; i < deleteCount; ++i) {\r\n        store<usize>(resultStart + (<usize>i << alignof<T>()),\r\n          load<usize>(thisBase + (<usize>i << alignof<T>()))\r\n        );\r\n        // no need to retain -> is moved\r\n      }\r\n    } else {\r\n      memory.copy(\r\n        resultStart,\r\n        thisBase,\r\n        <usize>deleteCount << alignof<T>()\r\n      );\r\n    }\r\n    var offset = start + deleteCount;\r\n    if (length != offset) {\r\n      memory.copy(\r\n        thisBase,\r\n        thisStart + (<usize>offset << alignof<T>()),\r\n        <usize>(length - offset) << alignof<T>()\r\n      );\r\n    }\r\n    this.length_ = length - deleteCount;\r\n    return result;\r\n  }\r\n\r\n  reverse(): Array<T> {\r\n    var length = this.length_;\r\n    if (length) {\r\n      let front = this.dataStart;\r\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\r\n      while (front < back) {\r\n        let temp = load<T>(front);\r\n        store<T>(front, load<T>(back));\r\n        store<T>(back, temp);\r\n        front += sizeof<T>();\r\n        back -= sizeof<T>();\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\r\n    var length = this.length_;\r\n    if (length <= 1) return this;\r\n    var base = this.dataStart;\r\n    if (length == 2) {\r\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\r\n      let b: T = load<T>(base); // b = arr[0]\r\n      if (comparator(a, b) < 0) {\r\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\r\n        store<T>(base, a); // arr[0] = a;\r\n      }\r\n      return this;\r\n    }\r\n    SORT<T>(base, length, comparator);\r\n    return this;\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    var dataStart = this.dataStart;\r\n    var length = this.length_;\r\n    if (isBoolean<T>())   return joinBooleanArray(dataStart, length, separator);\r\n    if (isInteger<T>())   return joinIntegerArray<T>(dataStart, length, separator);\r\n    if (isFloat<T>())     return joinFloatArray<T>(dataStart, length, separator);\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (isString<T>())  return joinStringArray(dataStart, length, separator);\r\n    }\r\n    // For rest objects and arrays use general join routine\r\n    if (isReference<T>()) return joinReferenceArray<T>(dataStart, length, separator);\r\n    ERROR(\"unspported element type\");\r\n    return <string>unreachable();\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  // RT integration\r\n\r\n  @unsafe private __visit_impl(cookie: u32): void {\r\n    if (isManaged<T>()) {\r\n      let cur = this.dataStart;\r\n      let end = cur + (<usize>this.length_ << alignof<T>());\r\n      while (cur < end) {\r\n        let val = load<usize>(cur);\r\n        if (val) __visit(val, cookie);\r\n        cur += sizeof<usize>();\r\n      }\r\n    }\r\n    // automatically visits ArrayBufferView (.buffer) next\r\n  }\r\n}\r\n","/// <reference path=\"../rt/index.d.ts\" />\r\n\r\nimport { idof } from \"../builtins\";\r\nimport { CharCode } from \"./string\";\r\nimport { ArrayBufferView } from \"../arraybuffer\";\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport const MAX_DOUBLE_LENGTH = 28;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst POWERS10: u32[] = [\r\n  1,\r\n  10,\r\n  100,\r\n  1000,\r\n  10000,\r\n  100000,\r\n  1000000,\r\n  10000000,\r\n  100000000,\r\n  1000000000\r\n];\r\n\r\n/*\r\n  Lookup table for pairwise char codes in range [0-99]\r\n\r\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\r\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\r\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\r\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\r\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\r\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\r\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\r\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\r\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\r\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\r\n*/\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst DIGITS: u32[] = [\r\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\r\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\r\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\r\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\r\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\r\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\r\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\r\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\r\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\r\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\r\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\r\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\r\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\r\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\r\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\r\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\r\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\r\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\r\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\r\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\r\n];\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst EXP_POWERS: i16[] = [\r\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\r\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\r\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\r\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\r\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\r\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\r\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\r\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\r\n    907,   933,   960,   986,  1013,  1039,  1066\r\n];\r\n\r\n// 1e-348, 1e-340, ..., 1e340\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst FRC_POWERS: u64[] = [\r\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\r\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\r\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\r\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\r\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\r\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\r\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\r\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\r\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\r\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\r\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\r\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\r\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\r\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\r\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\r\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\r\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\r\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\r\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\r\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\r\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\r\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\r\n];\r\n\r\n// Count number of decimals for u32 values\r\n// In our case input value always non-zero so we can simplify some parts\r\nexport function decimalCount32(value: u32): u32 {\r\n  if (value < 100000) {\r\n    if (value < 100) {\r\n      return select<u32>(1, 2, value < 10);\r\n    } else {\r\n      let m = select<u32>(4, 5, value < 10000);\r\n      return select<u32>(3, m, value < 1000);\r\n    }\r\n  } else {\r\n    if (value < 10000000) {\r\n      return select<u32>(6, 7, value < 1000000);\r\n    } else {\r\n      let m = select<u32>(9, 10, value < 1000000000);\r\n      return select<u32>(8, m, value < 100000000);\r\n    }\r\n  }\r\n}\r\n\r\n// Count number of decimals for u64 values\r\n// In our case input value always greater than 2^32-1 so we can skip some parts\r\nexport function decimalCount64(value: u64): u32 {\r\n  if (value < 1000000000000000) {\r\n    if (value < 1000000000000) {\r\n      let m = select<u32>(11, 12, value < 100000000000);\r\n      return select<u32>(10, m, value < 10000000000);\r\n    } else {\r\n      let m = select<u32>(14, 15, value < 100000000000000);\r\n      return select<u32>(13, m, value < 10000000000000);\r\n    }\r\n  } else {\r\n    if (value < 100000000000000000) {\r\n      return select<u32>(16, 17, value < 10000000000000000);\r\n    } else {\r\n      let m = select<u32>(19, 20, value < 10000000000000000000);\r\n      return select<u32>(18, m, value < 1000000000000000000);\r\n    }\r\n  }\r\n}\r\n\r\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\r\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\r\n  while (num >= 10000) {\r\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\r\n    let t = num / 10000;\r\n    let r = num % 10000;\r\n    num = t;\r\n\r\n    let d1 = r / 100;\r\n    let d2 = r % 100;\r\n\r\n    let digits1 = <u64>load<u32>(lut + (<usize>d1 << alignof<u32>()));\r\n    let digits2 = <u64>load<u32>(lut + (<usize>d2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n  }\r\n\r\n  if (num >= 100) {\r\n    let t  = num / 100;\r\n    let d1 = num % 100;\r\n    num = t;\r\n    offset -= 2;\r\n    let digits = load<u32>(lut + (<usize>d1 << alignof<u32>()));\r\n    store<u32>(buffer + (offset << 1), digits);\r\n  }\r\n\r\n  if (num >= 10) {\r\n    offset -= 2;\r\n    let digits = load<u32>(lut + (<usize>num << alignof<u32>()));\r\n    store<u32>(buffer + (offset << 1), digits);\r\n  } else {\r\n    offset -= 1;\r\n    let digit = CharCode._0 + num;\r\n    store<u16>(buffer + (offset << 1), digit);\r\n  }\r\n}\r\n\r\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\r\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\r\n  while (num >= 100000000) {\r\n    let t = num / 100000000;\r\n    let r = <usize>(num - t * 100000000);\r\n    num = t;\r\n\r\n    let b = r / 10000;\r\n    let c = r % 10000;\r\n\r\n    let b1 = b / 100;\r\n    let b2 = b % 100;\r\n    let c1 = c / 100;\r\n    let c2 = c % 100;\r\n\r\n    let digits1 = <u64>load<u32>(lut + (<usize>c1 << alignof<u32>()));\r\n    let digits2 = <u64>load<u32>(lut + (<usize>c2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n\r\n    digits1 = <u64>load<u32>(lut + (<usize>b1 << alignof<u32>()));\r\n    digits2 = <u64>load<u32>(lut + (<usize>b2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n  }\r\n\r\n  utoa32_lut(buffer, <u32>num, offset);\r\n}\r\n\r\nfunction utoa_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\r\n  do {\r\n    let t = num / 10;\r\n    let r = <u32>(num % 10);\r\n    num = changetype<T>(t);\r\n    offset -= 1;\r\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\r\n  } while (num);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_simple(buffer, num, offset);\r\n  } else {\r\n    utoa32_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_simple(buffer, num, offset);\r\n  } else {\r\n    utoa64_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\nexport function utoa32(value: u32): String {\r\n  if (!value) return \"0\";\r\n\r\n  var decimals = decimalCount32(value);\r\n  var out = __alloc(decimals << 1, idof<String>());\r\n\r\n  utoa32_core(out, value, decimals);\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function itoa32(value: i32): String {\r\n  if (!value) return \"0\";\r\n\r\n  var sign = value < 0;\r\n  if (sign) value = -value;\r\n\r\n  var decimals = decimalCount32(value) + u32(sign);\r\n  var out = __alloc(decimals << 1, idof<String>());\r\n\r\n  utoa32_core(out, value, decimals);\r\n  if (sign) store<u16>(out, CharCode.MINUS);\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function utoa64(value: u64): String {\r\n  if (!value) return \"0\";\r\n\r\n  var out: usize;\r\n  if (value <= u32.MAX_VALUE) {\r\n    let val32    = <u32>value;\r\n    let decimals = decimalCount32(val32);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa32_core(out, val32, decimals);\r\n  } else {\r\n    let decimals = decimalCount64(value);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa64_core(out, value, decimals);\r\n  }\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function itoa64(value: i64): String {\r\n  if (!value) return \"0\";\r\n\r\n  var sign = value < 0;\r\n  if (sign) value = -value;\r\n\r\n  var out: usize;\r\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n    let val32    = <u32>value;\r\n    let decimals = decimalCount32(val32) + u32(sign);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa32_core(out, val32, decimals);\r\n  } else {\r\n    let decimals = decimalCount64(value) + u32(sign);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa64_core(out, value, decimals);\r\n  }\r\n  if (sign) store<u16>(out, CharCode.MINUS);\r\n\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function itoa<T extends number>(value: T): String {\r\n  if (!isInteger<T>()) ERROR(\"integer type expected\");\r\n  if (isSigned<T>()) {\r\n    if (sizeof<T>() <= 4) {\r\n      return itoa32(<i32>value);\r\n    } else {\r\n      return itoa64(<i64>value);\r\n    }\r\n  } else {\r\n    if (sizeof<T>() <= 4) {\r\n      return utoa32(<u32>value);\r\n    } else {\r\n      return utoa64(<u64>value);\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _K: i32 = 0;\r\n\r\n// // @ts-ignore: decorator\r\n// @lazy\r\n// var _frc: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _exp: i32 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _frc_minus: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _frc_plus:  u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _frc_pow: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _exp_pow: i32 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umul64f(u: u64, v: u64): u64 {\r\n  var u0 = u & 0xFFFFFFFF;\r\n  var v0 = v & 0xFFFFFFFF;\r\n\r\n  var u1 = u >> 32;\r\n  var v1 = v >> 32;\r\n\r\n  var l = u0 * v0;\r\n  var t = u1 * v0 + (l >> 32);\r\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\r\n\r\n  w += 0x7FFFFFFF; // rounding\r\n\r\n  t >>= 32;\r\n  w >>= 32;\r\n\r\n  return u1 * v1 + t + w;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umul64e(e1: i32, e2: i32): i32 {\r\n  return e1 + e2 + 64; // where 64 is significand size\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction normalizedBoundaries(f: u64, e: i32): void {\r\n  var frc = (f << 1) + 1;\r\n  var exp = e - 1;\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var m = 1 + i32(f == 0x0010000000000000);\r\n\r\n  _frc_plus  = frc;\r\n  _frc_minus = ((f << m) - 1) << e - m - exp;\r\n  _exp = exp;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\r\n  var lastp = buffer + ((len - 1) << 1);\r\n  var digit = load<u16>(lastp);\r\n  while (\r\n    rest < wp_w &&\r\n    delta - rest >= ten_kappa && (\r\n      rest + ten_kappa < wp_w ||\r\n      wp_w - rest > rest + ten_kappa - wp_w\r\n    )\r\n  ) {\r\n    --digit;\r\n    rest += ten_kappa;\r\n  }\r\n  store<u16>(lastp, digit);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction getCachedPower(minExp: i32): void {\r\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\r\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\r\n  var k = <i32>dk;\r\n      k += i32(k != dk); // conversion with ceil\r\n\r\n  var index = (k >> 3) + 1;\r\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\r\n  _frc_pow = unchecked(FRC_POWERS[index]);\r\n  _exp_pow = unchecked(<i32>EXP_POWERS[index]);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\r\n\r\n  // frexp routine\r\n  var uv  = reinterpret<u64>(value);\r\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\r\n  var sid = uv & 0x000FFFFFFFFFFFFF;\r\n  var frc = (u64(exp != 0) << 52) + sid;\r\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\r\n\r\n  normalizedBoundaries(frc, exp);\r\n  getCachedPower(_exp);\r\n\r\n  // normalize\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var frc_pow = _frc_pow;\r\n  var exp_pow = _exp_pow;\r\n\r\n  var w_frc = umul64f(frc, frc_pow);\r\n  var w_exp = umul64e(exp, exp_pow);\r\n\r\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\r\n  var wp_exp = umul64e(_exp,      exp_pow);\r\n\r\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\r\n  var delta  = wp_frc - wm_frc;\r\n\r\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\r\n}\r\n\r\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\r\n  var one_exp = -mp_exp;\r\n  var one_frc = (<u64>1) << one_exp;\r\n  var mask    = one_frc - 1;\r\n\r\n  var wp_w_frc = mp_frc - w_frc;\r\n  var wp_w_exp = mp_exp;\r\n\r\n  var p1 = <u32>(mp_frc >> one_exp);\r\n  var p2 = mp_frc & mask;\r\n\r\n  var kappa = <i32>decimalCount32(p1);\r\n  var len = sign;\r\n\r\n  var lut = changetype<ArrayBufferView>(POWERS10).dataStart;\r\n\r\n  while (kappa > 0) {\r\n    let d: u32;\r\n    switch (kappa) {\r\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\r\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\r\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\r\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\r\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\r\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\r\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\r\n      case  3: { d = p1 /        100; p1 %=        100; break; }\r\n      case  2: { d = p1 /         10; p1 %=         10; break; }\r\n      case  1: { d = p1;              p1 =           0; break; }\r\n      default: { d = 0; break; }\r\n    }\r\n\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\r\n\r\n    --kappa;\r\n    let tmp = ((<u64>p1) << one_exp) + p2;\r\n    if (tmp <= delta) {\r\n      _K += kappa;\r\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(lut + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n\r\n  while (1) {\r\n    p2    *= 10;\r\n    delta *= 10;\r\n\r\n    let d = p2 >> one_exp;\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\r\n\r\n    p2 &= mask;\r\n    --kappa;\r\n    if (p2 < delta) {\r\n      _K += kappa;\r\n      wp_w_frc *= <u64>load<u32>(lut + (<usize>-kappa << alignof<u32>()));\r\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction genExponent(buffer: usize, k: i32): i32 {\r\n  var sign = k < 0;\r\n  if (sign) k = -k;\r\n  var decimals = decimalCount32(k) + 1;\r\n  utoa32_core(buffer, k, decimals);\r\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\r\n  return decimals;\r\n}\r\n\r\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\r\n  if (!k) {\r\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\r\n    return length + 2;\r\n  }\r\n\r\n  var kk = length + k;\r\n  if (length <= kk && kk <= 21) {\r\n    // 1234e7 -> 12340000000\r\n    for (let i = length; i < kk; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0);\r\n    }\r\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\r\n    return kk + 2;\r\n  } else if (kk > 0 && kk <= 21) {\r\n    // 1234e-2 -> 12.34\r\n    let ptr = buffer + (kk << 1);\r\n    memory.copy(\r\n      ptr + 2,\r\n      ptr,\r\n      -k << 1\r\n    );\r\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\r\n    return length + 1;\r\n  } else if (-6 < kk && kk <= 0) {\r\n    // 1234e-6 -> 0.001234\r\n    let offset = 2 - kk;\r\n    memory.copy(\r\n      buffer + (offset << 1),\r\n      buffer,\r\n      length << 1\r\n    );\r\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\r\n    for (let i = 2; i < offset; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0);\r\n    }\r\n    return length + offset;\r\n  } else if (length == 1) {\r\n    // 1e30\r\n    store<u16>(buffer, CharCode.e, 2);\r\n    length = genExponent(buffer + 4, kk - 1);\r\n    return length + 2;\r\n  } else {\r\n    let len = length << 1;\r\n    memory.copy(\r\n      buffer + 4,\r\n      buffer + 2,\r\n      len - 2\r\n    );\r\n    store<u16>(buffer,       CharCode.DOT, 2);\r\n    store<u16>(buffer + len, CharCode.e,   2);\r\n    length += genExponent(buffer + len + 4, kk - 1);\r\n    return length + 2;\r\n  }\r\n}\r\n\r\nexport function dtoa_core(buffer: usize, value: f64): i32 {\r\n  var sign = i32(value < 0);\r\n  if (sign) {\r\n    value = -value;\r\n    store<u16>(buffer, CharCode.MINUS);\r\n  }\r\n  // assert(value > 0 && value <= 1.7976931348623157e308);\r\n  var len = grisu2(value, buffer, sign);\r\n      len = prettify(buffer + (sign << 1), len - sign, _K);\r\n  return len + sign;\r\n}\r\n\r\nexport function dtoa(value: f64): String {\r\n  if (value == 0) return \"0.0\";\r\n  if (!isFinite<f64>(value)) {\r\n    if (isNaN<f64>(value)) return \"NaN\";\r\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\r\n  }\r\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\r\n  var length = dtoa_core(buffer, value);\r\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\r\n  var result = changetype<String>(buffer).substring(0, length);\r\n  __free(buffer);\r\n  return result;\r\n}\r\n\r\nexport function itoa_stream<T extends number>(buffer: usize, offset: usize, value: T): u32 {\r\n  buffer += (offset << 1);\r\n  if (!value) {\r\n    store<u16>(buffer, CharCode._0);\r\n    return 1;\r\n  }\r\n  var decimals: u32 = 0;\r\n  if (isSigned<T>()) {\r\n    let sign = i32(value < 0);\r\n    if (sign) value = changetype<T>(-value);\r\n    if (sizeof<T>() <= 4) {\r\n      decimals = decimalCount32(value) + <u32>sign;\r\n      utoa32_core(buffer, value, decimals);\r\n    } else {\r\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n        let val32 = <u32>value;\r\n        decimals = decimalCount32(val32) + <u32>sign;\r\n        utoa32_core(buffer, val32, decimals);\r\n      } else {\r\n        decimals = decimalCount64(value) + <u32>sign;\r\n        utoa64_core(buffer, value, decimals);\r\n      }\r\n    }\r\n    if (sign) store<u16>(buffer, CharCode.MINUS);\r\n  } else {\r\n    if (sizeof<T>() <= 4) {\r\n      decimals = decimalCount32(value);\r\n      utoa32_core(buffer, value, decimals);\r\n    } else {\r\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n        let val32 = <u32>value;\r\n        decimals = decimalCount32(val32);\r\n        utoa32_core(buffer, val32, decimals);\r\n      } else {\r\n        decimals = decimalCount64(value);\r\n        utoa64_core(buffer, value, decimals);\r\n      }\r\n    }\r\n  }\r\n  return decimals;\r\n}\r\n\r\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\r\n  buffer += (offset << 1);\r\n  if (value == 0.0) {\r\n    store<u16>(buffer, CharCode._0);\r\n    store<u16>(buffer, CharCode.DOT, 2);\r\n    store<u16>(buffer, CharCode._0,  4);\r\n    return 3;\r\n  }\r\n  if (!isFinite<f64>(value)) {\r\n    if (isNaN<f64>(value)) {\r\n      store<u16>(buffer, CharCode.N);\r\n      store<u16>(buffer, CharCode.a, 2);\r\n      store<u16>(buffer, CharCode.N, 4);\r\n      return 3;\r\n    } else {\r\n      let sign = i32(value < 0);\r\n      let len  = 8 + sign;\r\n      memory.copy(buffer, changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign)), len << 1);\r\n      return len;\r\n    }\r\n  }\r\n  return dtoa_core(buffer, value);\r\n}\r\n","import { itoa, dtoa, itoa_stream, dtoa_stream, MAX_DOUBLE_LENGTH } from \"./number\";\r\nimport { ipow32 } from \"../math\";\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  I = 0x49,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5A,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\n// 9 * 8 = 72 bytes\r\n// @ts-ignore: decorator\r\n@lazy\r\nconst Powers10Hi: f64[] = [1, 1e32, 1e64, 1e96, 1e128, 1e160, 1e192, 1e224, 1e256, 1e288];\r\n// 32 * 8 = 256 bytes\r\n// @ts-ignore: decorator\r\n@lazy\r\nconst Powers10Lo: f64[] = [\r\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\r\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\r\n  1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29,\r\n  1e30, 1e31\r\n];\r\n\r\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\r\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\r\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\r\n      do {\r\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\r\n        ptr1 += 8;\r\n        ptr2 += 8;\r\n        len  -= 4;\r\n      } while (len >= 4);\r\n    }\r\n  }\r\n  while (len--) {\r\n    let a = <i32>load<u16>(ptr1);\r\n    let b = <i32>load<u16>(ptr2);\r\n    if (a != b) return a - b;\r\n    ptr1 += 2;\r\n    ptr2 += 2;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport function isSpace(c: i32): bool {\r\n  if (c <= 0xFF) {\r\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\r\n    return c == 0x20 || <u32>(c - 0x09) <= 0x0D - 0x09 || c == 0xA0;\r\n  }\r\n  if (<u32>(c - 0x2000) <= 0x200A - 0x2000) return true;\r\n  switch (c) {\r\n    case 0x1680: // <LS> (1)\r\n    case 0x2028: // <LS> (2)\r\n    case 0x2029: // <PS>\r\n    case 0x202F: // <NNS>\r\n    case 0x205F: // <MMSP>\r\n    case 0x3000: // <IS>\r\n    case 0xFEFF: return true; // <ZWNBSP>\r\n  }\r\n  return false;\r\n}\r\n\r\n/** Parses a string to an integer (usually), using the specified radix. */\r\nexport function strtol<T>(str: string, radix: i32 = 0): T {\r\n  var len = str.length;\r\n  if (!len) {\r\n    // @ts-ignore: cast\r\n    if (isFloat<T>()) return <T>NaN;\r\n    // @ts-ignore: cast\r\n    return <T>0;\r\n  }\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <u32>load<u16>(ptr);\r\n\r\n  // determine sign\r\n  // @ts-ignore: cast\r\n  var sign: T = 1;\r\n  // trim white spaces\r\n  while (isSpace(code)) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) {\r\n      // @ts-ignore: cast\r\n      if (isFloat<T>()) return <T>NaN;\r\n      // @ts-ignore: cast\r\n      return <T>0;\r\n    }\r\n    code = <u32>load<u16>(ptr += 2);\r\n    // @ts-ignore: type\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) {\r\n      // @ts-ignore: cast\r\n      if (isFloat<T>()) return <T>NaN;\r\n      // @ts-ignore: cast\r\n      return <T>0;\r\n    }\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<u32>load<u16>(ptr + 2) | 32) {\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n        default: radix = 10;\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36) {\r\n    // @ts-ignore: cast\r\n    if (isFloat<T>()) return <T>NaN;\r\n    // @ts-ignore: cast\r\n    return <T>0;\r\n  }\r\n\r\n  // calculate value\r\n  // @ts-ignore: type\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <u32>load<u16>(ptr);\r\n    if (code - CharCode._0 < 10) {\r\n      code -= CharCode._0;\r\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\r\n      code -= CharCode.a - 10;\r\n    } else break;\r\n    if (code >= <u32>radix) break;\r\n    // @ts-ignore: type\r\n    num = num * radix + code;\r\n    ptr += 2;\r\n  }\r\n  // @ts-ignore: type\r\n  return sign * num;\r\n}\r\n\r\nexport function strtod(str: string): f64 {\r\n  var len = str.length;\r\n  if (!len) return NaN;\r\n\r\n  var ptr  = changetype<usize>(str);\r\n  var code = <u32>load<u16>(ptr);\r\n\r\n  var sign = 1.;\r\n  // skip white spaces\r\n  while (len && isSpace(code)) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (!len) return NaN;\r\n\r\n  // try parse '-' or '+'\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return NaN;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return NaN;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  // try parse Infinity\r\n  if (len >= 8 && code == CharCode.I) {\r\n    if (\r\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\r\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\r\n    ) {\r\n      return copysign<f64>(Infinity, sign);\r\n    }\r\n    return NaN;\r\n  }\r\n  // validate next symbol\r\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\r\n    return NaN;\r\n  }\r\n  var savedPtr = ptr;\r\n  // skip zeros\r\n  while (code == CharCode._0) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (len <= 0) return 0;\r\n  const capacity = 19; // int(64 * 0.3010)\r\n  var pointed = false;\r\n  var consumed = 0;\r\n  var position = 0;\r\n  var x: u64 = 0;\r\n  if (code == CharCode.DOT) {\r\n    let noDigits = !(savedPtr - ptr);\r\n    ptr += 2; --len;\r\n    if (!len && noDigits) return NaN;\r\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\r\n    if (len <= 0) return 0;\r\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\r\n  }\r\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\r\n    if (digit < 10) {\r\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\r\n      ++consumed;\r\n    } else {\r\n      position = consumed;\r\n      pointed = true;\r\n    }\r\n    if (!--len) break;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  if (!pointed) position = consumed;\r\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\r\n}\r\n\r\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\r\n\r\n  var sepLen = separator.length;\r\n  var valueLen = 5; // max possible length of element len(\"false\")\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\r\n  var offset = 0;\r\n  var value: bool;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<bool>(dataStart + i);\r\n    valueLen = 4 + i32(!value);\r\n    memory.copy(\r\n      changetype<usize>(result) + (<usize>offset << 1),\r\n      changetype<usize>(select(\"true\", \"false\", value)),\r\n      <usize>valueLen << 1\r\n    );\r\n    offset += valueLen;\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<bool>(dataStart + <usize>lastIndex);\r\n  valueLen = 4 + i32(!value);\r\n  memory.copy(\r\n    changetype<usize>(result) + (<usize>offset << 1),\r\n    changetype<usize>(select(\"true\", \"false\", value)),\r\n    valueLen << 1\r\n  );\r\n  offset += valueLen;\r\n\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  // @ts-ignore: type\r\n  if (!lastIndex) return changetype<string>(itoa<T>(load<T>(dataStart))); // retains\r\n\r\n  var sepLen = separator.length;\r\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\r\n  var offset = 0;\r\n  var value: T;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    // @ts-ignore: type\r\n    offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  // @ts-ignore: type\r\n  offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) {\r\n    return changetype<string>(dtoa(\r\n      // @ts-ignore: type\r\n      load<T>(dataStart))\r\n    ); // retains\r\n  }\r\n\r\n  const valueLen = MAX_DOUBLE_LENGTH;\r\n  var sepLen = separator.length;\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\r\n  var offset = 0;\r\n  var value: T;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    offset += dtoa_stream(changetype<usize>(result), offset,\r\n      // @ts-ignore: type\r\n      value\r\n    );\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  offset += dtoa_stream(changetype<usize>(result), offset,\r\n    // @ts-ignore: type\r\n    value\r\n  );\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) {\r\n    // @ts-ignore: type\r\n    return load<string>(dataStart) || \"\";\r\n  }\r\n  var estLen = 0;\r\n  var value: string;\r\n  for (let i = 0; i < length; ++i) {\r\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\r\n    // @ts-ignore: type\r\n    if (value !== null) estLen += value.length;\r\n  }\r\n  var offset = 0;\r\n  var sepLen = separator.length;\r\n  var result = __alloc((estLen + sepLen * lastIndex) << 1, idof<string>());\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\r\n    if (value !== null) {\r\n      let valueLen = value.length;\r\n      memory.copy(\r\n        result + (<usize>offset << 1),\r\n        changetype<usize>(value),\r\n        <usize>valueLen << 1\r\n      );\r\n      offset += valueLen;\r\n    }\r\n    if (sepLen) {\r\n      memory.copy(\r\n        result + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\r\n  if (value !== null) {\r\n    memory.copy(\r\n      result + (<usize>offset << 1),\r\n      changetype<usize>(value),\r\n      <usize>value.length << 1\r\n    );\r\n  }\r\n  return changetype<string>(result); // retains\r\n}\r\n\r\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  var value: T;\r\n  if (!lastIndex) {\r\n    value = load<T>(dataStart);\r\n    // @ts-ignore: type\r\n    return value !== null ? value.toString() : \"\";\r\n  }\r\n  var result = \"\";\r\n  var sepLen = separator.length;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    // @ts-ignore: type\r\n    if (value !== null) result += value.toString();\r\n    if (sepLen) result += separator;\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  // @ts-ignore: type\r\n  if (value !== null) result += value.toString();\r\n  return result;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scientific(significand: u64, exp: i32): f64 {\r\n  if (!significand || exp < -342) return 0;\r\n  if (exp > 308) return Infinity;\r\n  // Try use fast path\r\n  // Use fast path for string-to-double conversion if possible\r\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\r\n  // Simple integer\r\n  var significandf = <f64>significand;\r\n  if (!exp) return significandf;\r\n  if (exp > 22 && exp <= 22 + 15) {\r\n    significandf *= pow10(exp - 22);\r\n    exp = 22;\r\n  }\r\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\r\n    if (exp > 0) return significandf * pow10(exp);\r\n    return significandf / pow10(-exp);\r\n  } else if (exp < 0) {\r\n    return scaledown(significand, exp);\r\n  } else {\r\n    return scaleup(significand, exp);\r\n  }\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scaledown(significand: u64, exp: i32): f64 {\r\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\r\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\r\n\r\n  var shift = clz(significand);\r\n  significand <<= shift;\r\n  shift = exp - shift;\r\n\r\n  for (; exp <= -14; exp += 14) {\r\n    let q = significand / denom;\r\n    let r = significand % denom;\r\n    let s = clz(q);\r\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\r\n    shift -= s;\r\n  }\r\n  var b = <u64>ipow32(5, -exp);\r\n  var q = significand / b;\r\n  var r = significand % b;\r\n  var s = clz(q);\r\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\r\n  shift -= s;\r\n\r\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scaleup(significand: u64, exp: i32): f64 {\r\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\r\n  var shift = ctz(significand);\r\n  significand >>= shift;\r\n  shift += exp;\r\n\r\n  __fixmulShift = shift;\r\n  for (; exp >= 13; exp -= 13) {\r\n    significand = fixmul(significand, coeff);\r\n  }\r\n  significand = fixmul(significand, <u32>ipow32(5, exp));\r\n  shift = __fixmulShift;\r\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction parseExp(ptr: usize, len: i32): i32 {\r\n  var sign = 1, magnitude = 0;\r\n  var code = <u32>load<u16>(ptr);\r\n  // check code is 'e' or 'E'\r\n  if ((code | 32) != CharCode.e) return 0;\r\n\r\n  code = <u32>load<u16>(ptr += 2);\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n  // skip zeros\r\n  while (code == CharCode._0) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\r\n    if (magnitude >= 3200) return sign * 3200;\r\n    magnitude = 10 * magnitude + digit;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  return sign * magnitude;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar __fixmulShift: u64 = 0;\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction fixmul(a: u64, b: u32): u64 {\r\n  var low  = (a & 0xFFFFFFFF) * b;\r\n  var high = (a >> 32) * b + (low >> 32);\r\n  var overflow = <u32>(high >> 32);\r\n  var space = clz(overflow);\r\n  var revspace: u64 = 32 - space;\r\n  __fixmulShift += revspace;\r\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\r\n}\r\n\r\n// @ts-ignore: decorator\r\nfunction pow10(n: i32): f64 {\r\n  // @ts-ignore: type\r\n  const hi = Powers10Hi.dataStart;\r\n  // @ts-ignore: type\r\n  const lo = Powers10Lo.dataStart;\r\n  return (\r\n    load<f64>(hi + ((n >> 5) << alignof<f64>())) *\r\n    load<f64>(lo + ((n & 31) << alignof<f64>()))\r\n  );\r\n}\r\n","import { itoa, dtoa } from \"./util/number\";\r\nimport { strtol } from \"./util/string\";\r\n\r\n// @ts-ignore: decorator\r\n@builtin @inline\r\nexport const NaN: f64 = 0 / 0;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @inline\r\nexport const Infinity: f64 = 1 / 0;\r\n\r\nexport function isNaN<T extends number>(value: T): bool {\r\n  if (!isFloat<T>()) {\r\n    if (!isInteger<T>()) ERROR(\"numeric type expected\");\r\n  }\r\n  return value != value;\r\n}\r\n\r\nexport function isFinite<T extends number>(value: T): bool {\r\n  if (!isFloat<T>()) {\r\n    if (!isInteger<T>()) ERROR(\"numeric type expected\");\r\n  }\r\n  return value - value == 0;\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I8 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i8 {\r\n    return <i8>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i8): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I16 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i16 {\r\n    return <i16>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i16): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i32 {\r\n    return <i32>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i32): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i64 {\r\n    return strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: i64): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class Isize {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): isize {\r\n    return <isize>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: isize): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U8 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u8 {\r\n    return <u8>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u8): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U16 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u16 {\r\n    return <u16>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u16): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u32 {\r\n    return <u32>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u32): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u64 {\r\n    return <u64>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: u64): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class Usize {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): usize {\r\n    return <usize>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: usize): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class Bool {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\r\n\r\n  toString(this: bool): String {\r\n    // TODO: radix?\r\n    return this ? \"true\" : \"false\";\r\n  }\r\n}\r\n\r\nexport { Bool as Boolean };\r\n\r\n@sealed @unmanaged\r\nexport abstract class F32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly EPSILON: f32 = f32.EPSILON;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly POSITIVE_INFINITY: f32 = Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NEGATIVE_INFINITY: f32 = -Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NaN: f32 = NaN;\r\n\r\n  static isNaN(value: f32): bool {\r\n    return isNaN<f32>(value);\r\n  }\r\n\r\n  static isFinite(value: f32): bool {\r\n    return isFinite<f32>(value);\r\n  }\r\n\r\n  static isSafeInteger(value: f32): bool {\r\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\r\n  }\r\n\r\n  static isInteger(value: f32): bool {\r\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\r\n  }\r\n\r\n  static parseInt(value: string, radix: i32 = 0): f32 {\r\n    return <f32>strtol<i64>(value, radix);\r\n  }\r\n\r\n  static parseFloat(value: string): f32 {\r\n    return <f32>parseFloat(value);\r\n  }\r\n\r\n  toString(this: f32): String {\r\n    // TODO: radix\r\n    return dtoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class F64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly EPSILON: f64 = f64.EPSILON;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly POSITIVE_INFINITY: f64 = Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NEGATIVE_INFINITY: f64 = -Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NaN: f64 = NaN;\r\n\r\n  static isNaN(value: f64): bool {\r\n    return isNaN<f64>(value);\r\n  }\r\n\r\n  static isFinite(value: f64): bool {\r\n    return isFinite<f64>(value);\r\n  }\r\n\r\n  static isSafeInteger(value: f64): bool {\r\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\r\n  }\r\n\r\n  static isInteger(value: f64): bool {\r\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\r\n  }\r\n\r\n  static parseInt(value: string, radix: i32 = 0): f64 {\r\n    return <f64>strtol<i64>(value, radix);\r\n  }\r\n\r\n  static parseFloat(value: string): f64 {\r\n    return parseFloat(value);\r\n  }\r\n\r\n  toString(this: f64, radix: i32 = 0): String {\r\n    // TODO: radix\r\n    return dtoa(this);\r\n  }\r\n}\r\n\r\nexport { F64 as Number };\r\n","import * as JSMath from \"./bindings/Math\";\r\nexport { JSMath };\r\n\r\nimport {\r\n  abs as builtin_abs,\r\n  ceil as builtin_ceil,\r\n  clz as builtin_clz,\r\n  copysign as builtin_copysign,\r\n  floor as builtin_floor,\r\n  max as builtin_max,\r\n  min as builtin_min,\r\n  sqrt as builtin_sqrt,\r\n  trunc as builtin_trunc\r\n} from \"./builtins\";\r\n\r\n// SUN COPYRIGHT NOTICE\r\n//\r\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\r\n// Developed at SunPro, a Sun Microsystems, Inc. business.\r\n// Permission to use, copy, modify, and distribute this software\r\n// is freely granted, provided that this notice is preserved.\r\n//\r\n// Applies to all functions marked with a comment referring here.\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar rempio2_y0: f64,\r\n    rempio2_y1: f64,\r\n    res128_hi: u64;\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@lazy\r\nconst PIO2_TABLE: u64[] = [\r\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\r\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\r\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\r\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\r\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\r\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\r\n];\r\n\r\n/** @internal */\r\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\r\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\r\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\r\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\r\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\r\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\r\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\r\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\r\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\r\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\r\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\r\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\r\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\r\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\r\n  return p / q;\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction expo2(x: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\r\n  const                       // see: musl/src/math/__expo2.c\r\n    k    = <u32>2043,\r\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\r\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\r\n  return NativeMath.exp(x - kln2) * scale * scale;\r\n}\r\n\r\n/** @internal */\r\n/* Helper function to eventually get bits of π/2 * |x|\r\n *\r\n * y = π/4 * (frac << clz(frac) >> 11)\r\n * return clz(frac)\r\n *\r\n * Right shift 11 bits to make upper half fit in `double`\r\n */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\r\n  /* Bits of π/4 */\r\n  const p0: u64 = 0xC4C6628B80DC1CD1;\r\n  const p1: u64 = 0xC90FDAA22168C234;\r\n\r\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\r\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\r\n\r\n  var shift = clz(q1);\r\n\r\n  q1 = q1 << shift | q0 >> (64 - shift);\r\n  q0 <<= shift;\r\n\r\n  var lo = umuldi(p1, q1);\r\n  var hi = res128_hi;\r\n\r\n  var ahi = hi >> 11;\r\n  var alo = lo >> 11 | hi << 53;\r\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\r\n\r\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\r\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\r\n\r\n  return shift;\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umuldi(u: u64, v: u64): u64 {\r\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\r\n\r\n  u1 = u & 0xFFFFFFFF;\r\n  v1 = v & 0xFFFFFFFF;\r\n\r\n  u >>= 32;\r\n  v >>= 32;\r\n\r\n  t  = u1 * v1;\r\n  w0 = t & 0xFFFFFFFF;\r\n  t  = u * v1 + (t >> 32);\r\n  w1 = t >> 32;\r\n  t  = u1 * v + (t & 0xFFFFFFFF);\r\n\r\n  res128_hi = u * v + w1 + (t >> 32);\r\n  return (t << 32) + w0;\r\n}\r\n\r\n/** @internal */\r\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\r\n  const bits = PIO2_TABLE.dataStart;\r\n\r\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\r\n  var offset = (magnitude >> 52) - 1045;\r\n  var shift  = offset & 63;\r\n  var tblPtr = bits + (<i32>(offset >> 6) << 3);\r\n  var s0: u64, s1: u64, s2: u64;\r\n\r\n  var b0 = load<u64>(tblPtr, 0 << 3);\r\n  var b1 = load<u64>(tblPtr, 1 << 3);\r\n  var b2 = load<u64>(tblPtr, 2 << 3);\r\n\r\n  /* Get 192 bits of 0x1p-31 / π with `offset` bits skipped */\r\n  if (shift) {\r\n    let rshift = 64 - shift;\r\n    let b3 = load<u64>(tblPtr, 3 << 3);\r\n    s0 = b1 >> rshift | b0 << shift;\r\n    s1 = b2 >> rshift | b1 << shift;\r\n    s2 = b3 >> rshift | b2 << shift;\r\n  } else {\r\n    s0 = b0;\r\n    s1 = b1;\r\n    s2 = b2;\r\n  }\r\n\r\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\r\n\r\n  /* First 128 bits of fractional part of x/(2π) */\r\n  var blo = umuldi(s1, significand);\r\n  var bhi = res128_hi;\r\n\r\n  var ahi = s0 * significand;\r\n  var clo = (s2 >> 32) * (significand >> 32);\r\n  var plo = blo + clo;\r\n  var phi = ahi + bhi + u64(plo < clo);\r\n\r\n  // r: u128 = p << 2\r\n  var rlo = plo << 2;\r\n  var rhi = phi << 2 | plo >> 62;\r\n\r\n  // s: i128 = r >> 127\r\n  var slo = <i64>rhi >> 63;\r\n  var shi = slo >> 1;\r\n  var q   = (<i64>phi >> 62) - slo;\r\n\r\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\r\n  var signbit = (u ^ rhi) & 0x8000000000000000;\r\n  var coeff = reinterpret<f64>(shifter | signbit);\r\n\r\n  rempio2_y0 *= coeff;\r\n  rempio2_y1 *= coeff;\r\n\r\n  return <i32>q;\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\r\n  const pio2_1  = reinterpret<f64>(0x3FF921FB54400000); // 1.57079632673412561417e+00\r\n  const pio2_1t = reinterpret<f64>(0x3DD0B4611A626331); // 6.07710050650619224932e-11\r\n  const pio2_2  = reinterpret<f64>(0x3DD0B4611A600000); // 6.07710050630396597660e-11\r\n  const pio2_2t = reinterpret<f64>(0x3BA3198A2E037073); // 2.02226624879595063154e-21\r\n  const pio2_3  = reinterpret<f64>(0x3BA3198A2E000000); // 2.02226624871116645580e-21\r\n  const pio2_3t = reinterpret<f64>(0x397B839A252049C1); // 8.47842766036889956997e-32\r\n  const invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\r\n\r\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\r\n\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (ix < 0x4002D97C) { /* |x| < 3pi/4, special case with n=+-1 */\r\n      let q = 1, z: f64, y0: f64, y1: f64;\r\n      if (!sign) {\r\n        z = x - pio2_1;\r\n        if (ix != 0x3FF921FB) { /* 33+53 bit pi is good enough */\r\n          y0 = z - pio2_1t;\r\n          y1 = (z - y0) - pio2_1t;\r\n        } else { /* near pi/2, use 33+33+53 bit pi */\r\n          z -= pio2_2;\r\n          y0 = z - pio2_2t;\r\n          y1 = (z - y0) - pio2_2t;\r\n        }\r\n      } else { /* negative x */\r\n        z = x + pio2_1;\r\n        if (ix != 0x3FF921FB) { /* 33+53 bit pi is good enough */\r\n          y0 = z + pio2_1t;\r\n          y1 = (z - y0) + pio2_1t;\r\n        } else { /* near pi/2, use 33+33+53 bit pi */\r\n          z += pio2_2;\r\n          y0 = z + pio2_2t;\r\n          y1 = (z - y0) + pio2_2t;\r\n        }\r\n        q = -1;\r\n      }\r\n      rempio2_y0 = y0;\r\n      rempio2_y1 = y1;\r\n      return q;\r\n    }\r\n  }\r\n\r\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\r\n    // Use precise Cody Waite scheme\r\n    let q  = nearest(x * invpio2);\r\n    let r  = x - q * pio2_1;\r\n    let w  = q * pio2_1t; // 1st round good to 85 bit\r\n    let j  = ix >> 20;\r\n    let y0 = r - w;\r\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\r\n    let i  = j - ((hi >> 20) & 0x7FF);\r\n\r\n    if (i > 16) { // 2nd iteration needed, good to 118\r\n      let t = r;\r\n      w  = q * pio2_2;\r\n      r  = t - w;\r\n      w  = q * pio2_2t - ((t - r) - w);\r\n      y0 = r - w;\r\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\r\n      i = j - ((hi >> 20) & 0x7FF);\r\n      if (i > 49) { // 3rd iteration need, 151 bits acc\r\n        let t = r;\r\n        w  = q * pio2_3;\r\n        r  = t - w;\r\n        w  = q * pio2_3t - ((t - r) - w);\r\n        y0 = r - w;\r\n      }\r\n    }\r\n    let y1 = (r - y0) - w;\r\n    rempio2_y0 = y0;\r\n    rempio2_y1 = y1;\r\n    return <i32>q;\r\n  }\r\n  var q = pio2_large_quot(x, u);\r\n  return select(-q, q, sign);\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\r\n  const S1 = reinterpret<f64>(0xBFC5555555555549); // -1.66666666666666324348e-01\r\n  const S2 = reinterpret<f64>(0x3F8111111110F8A6); //  8.33333333332248946124e-03\r\n  const S3 = reinterpret<f64>(0xBF2A01A019C161D5); // -1.98412698298579493134e-04\r\n  const S4 = reinterpret<f64>(0x3EC71DE357B1FE7D); //  2.75573137070700676789e-06\r\n  const S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB); // -2.50507602534068634195e-08\r\n  const S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\r\n  var v = z * x;\r\n  if (!iy) {\r\n    return x + v * (S1 + z * r);\r\n  } else {\r\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\r\n  }\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\r\n  const C1 = reinterpret<f64>(0x3FA555555555554C); //  4.16666666666666019037e-02\r\n  const C2 = reinterpret<f64>(0xBF56C16C16C15177); // -1.38888888888741095749e-03\r\n  const C3 = reinterpret<f64>(0x3EFA01A019CB1590); //  2.48015872894767294178e-05\r\n  const C4 = reinterpret<f64>(0xBE927E4F809C52AD); // -2.75573143513906633035e-07\r\n  const C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4); //  2.08757232129817482790e-09\r\n  const C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\r\n  var hz = 0.5 * z;\r\n  w = 1.0 - hz;\r\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\r\n}\r\n\r\n/** @internal */\r\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\r\n  const T0  = reinterpret<f64>(0x3FD5555555555563); //  3.33333333333334091986e-01\r\n  const T1  = reinterpret<f64>(0x3FC111111110FE7A); //  1.33333333333201242699e-01\r\n  const T2  = reinterpret<f64>(0x3FABA1BA1BB341FE); //  5.39682539762260521377e-02\r\n  const T3  = reinterpret<f64>(0x3F9664F48406D637); //  2.18694882948595424599e-02\r\n  const T4  = reinterpret<f64>(0x3F8226E3E96E8493); //  8.86323982359930005737e-03\r\n  const T5  = reinterpret<f64>(0x3F6D6D22C9560328); //  3.59207910759131235356e-03\r\n  const T6  = reinterpret<f64>(0x3F57DBC8FEE08315); //  1.45620945432529025516e-03\r\n  const T7  = reinterpret<f64>(0x3F4344D8F2F26501); //  5.88041240820264096874e-04\r\n  const T8  = reinterpret<f64>(0x3F3026F71A8D1068); //  2.46463134818469906812e-04\r\n  const T9  = reinterpret<f64>(0x3F147E88A03792A6); //  7.81794442939557092300e-05\r\n  const T10 = reinterpret<f64>(0x3F12B80F32F0A7E9); //  7.14072491382608190305e-05\r\n  const T11 = reinterpret<f64>(0xBEF375CBDB605373); // -1.85586374855275456654e-05\r\n  const T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\r\n\r\n  const one    = reinterpret<f64>(0x3FF0000000000000); // 1.00000000000000000000e+00\r\n  const pio4   = reinterpret<f64>(0x3FE921FB54442D18); // 7.85398163397448278999e-01\r\n  const pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\r\n\r\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\r\n  var hx = <i32>(reinterpret<u64>(x) >> 32); /* high word of x */\r\n  var ix = hx & 0x7FFFFFFF; /* high word of |x| */\r\n  var big = ix >= 0x3FE59428;\r\n  if (big) { /* |x| >= 0.6744 */\r\n    if (hx < 0) { x = -x, y = -y; }\r\n    z = pio4 - x;\r\n    w = pio4lo - y;\r\n    x = z + w;\r\n    y = 0.0;\r\n  }\r\n  z = x * x;\r\n  w = z * z;\r\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\r\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\r\n  s = z * x;\r\n  r = y + z * (s * (r + v) + y);\r\n  r += T0 * s;\r\n  w = x + r;\r\n  if (big) {\r\n    v = iy;\r\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\r\n  }\r\n  if (iy == 1) return w;\r\n  var a: f64, t: f64;\r\n  z = w;\r\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\r\n  v = r - (z - x);  /* z + v = r + x */\r\n  t = a = -one / w; /* a = -1.0 / w */\r\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\r\n  s = one + t * z;\r\n  return t + a * (s + t * v);\r\n}\r\n\r\n/** @internal */\r\nfunction dtoi32(x: f64): i32 {\r\n  if (ASC_SHRINK_LEVEL > 0) {\r\n    const inv32 = 1.0 / 4294967296;\r\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\r\n  } else {\r\n    let result = 0;\r\n    let u = reinterpret<u64>(x);\r\n    let e = (u >> 52) & 0x7FF;\r\n    if (e <= 1023 + 30) {\r\n      result = <i32>x;\r\n    } else if (e <= 1023 + 30 + 53) {\r\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\r\n      v = v << e - 1023 - 52 + 32;\r\n      result = <i32>(v >> 32);\r\n      result = select<i32>(-result, result, u >> 63);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar random_seeded = false;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar random_state0_64: u64;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar random_state1_64: u64;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar random_state0_32: u32;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar random_state1_32: u32;\r\n\r\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\r\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\r\n  h *= 0xFF51AFD7ED558CCD;\r\n  h ^= h >> 33;\r\n  h *= 0xC4CEB9FE1A85EC53;\r\n  h ^= h >> 33;\r\n  return h;\r\n}\r\n\r\nfunction splitMix32(h: u32): u32 {\r\n  h += 0x6D2B79F5;\r\n  h  = (h ^ (h >> 15)) * (h | 1);\r\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\r\n  return h ^ (h >> 14);\r\n}\r\n\r\nexport namespace NativeMath {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_sin: f64 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_cos: f64 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @inline export function abs(x: f64): f64 {\r\n    return builtin_abs<f64>(x);\r\n  }\r\n\r\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\r\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3FF00000) {\r\n      let lx = <u32>reinterpret<u64>(x);\r\n      if ((ix - 0x3FF00000 | lx) == 0) {\r\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\r\n        return 0;\r\n      }\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3FE00000) {\r\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\r\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\r\n    }\r\n    var s: f64, w: f64, z: f64;\r\n    if (hx >> 31) {\r\n      // z = (1.0 + x) * 0.5;\r\n      z = 0.5 + x * 0.5;\r\n      s = builtin_sqrt<f64>(z);\r\n      w = R(z) * s - pio2_lo;\r\n      return 2 * (pio2_hi - (s + w));\r\n    }\r\n    // z = (1.0 - x) * 0.5;\r\n    z = 0.5 - x * 0.5;\r\n    s = builtin_sqrt<f64>(z);\r\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\r\n    var c = (z - df * df) / (s + df);\r\n    w = R(z) * s + c;\r\n    return 2 * (df + w);\r\n  }\r\n\r\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\r\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\r\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\r\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\r\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\r\n    return log(x) + s;\r\n  }\r\n\r\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\r\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3FF00000) {\r\n      let lx = <u32>reinterpret<u64>(x);\r\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3FE00000) {\r\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\r\n      return x + x * R(x * x);\r\n    }\r\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\r\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\r\n    var s = builtin_sqrt<f64>(z);\r\n    var r = R(z);\r\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\r\n    else {\r\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\r\n      let c = (z - f * f) / (s + f);\r\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\r\n    }\r\n    if (hx >> 31) return -x;\r\n    return x;\r\n  }\r\n\r\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\r\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\r\n    var u = reinterpret<u64>(x);\r\n    var e = u >> 52 & 0x7FF;\r\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\r\n    if (e >= 0x3FF + 26) y = log(y) + c;\r\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\r\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\r\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\r\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\r\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\r\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\r\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\r\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\r\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\r\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\r\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\r\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\r\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\r\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\r\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\r\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\r\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\r\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\r\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\r\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\r\n    var sx = x;\r\n    ix &= 0x7FFFFFFF;\r\n    var z: f64;\r\n    if (ix >= 0x44100000) {\r\n      if (isNaN(x)) return x;\r\n      z = atanhi3 + Ox1p_120f;\r\n      return builtin_copysign<f64>(z, sx);\r\n    }\r\n    var id: i32;\r\n    if (ix < 0x3FDC0000) {\r\n      if (ix < 0x3E400000) return x;\r\n      id = -1;\r\n    } else {\r\n      x = builtin_abs<f64>(x);\r\n      if (ix < 0x3FF30000) {\r\n        if (ix < 0x3FE60000) {\r\n          id = 0;\r\n          x = (2.0 * x - 1.0) / (2.0 + x);\r\n        } else {\r\n          id = 1;\r\n          x = (x - 1.0) / (x + 1.0);\r\n        }\r\n      } else {\r\n        if (ix < 0x40038000) {\r\n          id = 2;\r\n          x = (x - 1.5) / (1.0 + 1.5 * x);\r\n        } else {\r\n          id = 3;\r\n          x = -1.0 / x;\r\n        }\r\n      }\r\n    }\r\n    z = x * x;\r\n    var w = z * z;\r\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\r\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\r\n    var s3 = x * (s1 + s2);\r\n    if (id < 0) return x - s3;\r\n    switch (id) {\r\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\r\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\r\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\r\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\r\n      default: unreachable();\r\n    }\r\n    return builtin_copysign<f64>(z, sx);\r\n  }\r\n\r\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\r\n    var u = reinterpret<u64>(x);\r\n    var e = u >> 52 & 0x7FF;\r\n    var y = builtin_abs(x);\r\n    if (e < 0x3FF - 1) {\r\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\r\n    } else {\r\n      y = 0.5 * log1p(2 * (y / (1 - y)));\r\n    }\r\n    return builtin_copysign<f64>(y, x);\r\n  }\r\n\r\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\r\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\r\n    if (isNaN(x) || isNaN(y)) return x + y;\r\n    var u = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var lx = <u32>u;\r\n    u = reinterpret<u64>(y);\r\n    var iy = <u32>(u >> 32);\r\n    var ly = <u32>u;\r\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\r\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\r\n    ix = ix & 0x7FFFFFFF;\r\n    iy = iy & 0x7FFFFFFF;\r\n    if ((iy | ly) == 0) {\r\n      switch (m) {\r\n        case 0:\r\n        case 1: return  y;\r\n        case 2: return  PI;\r\n        case 3: return -PI;\r\n      }\r\n    }\r\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\r\n    if (ix == 0x7FF00000) {\r\n      if (iy == 0x7FF00000) {\r\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\r\n        return m & 1 ? -t : t;\r\n      } else {\r\n        let t = m & 2 ? PI : 0;\r\n        return m & 1 ? -t : t;\r\n      }\r\n    }\r\n    var z: f64;\r\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\r\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\r\n    else z = atan(builtin_abs<f64>(y / x));\r\n    switch (m) {\r\n      case 0: return  z;\r\n      case 1: return -z;\r\n      case 2: return PI - (z - pi_lo);\r\n      case 3: return (z - pi_lo) - PI;\r\n    }\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      B1     = <u32>715094163,\r\n      B2     = <u32>696219795,\r\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\r\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\r\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\r\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\r\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\r\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\r\n    if (hx >= 0x7FF00000) return x + x;\r\n    if (hx < 0x00100000) {\r\n      u = reinterpret<u64>(x * Ox1p54);\r\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\r\n      if (hx == 0) return x;\r\n      hx = hx / 3 + B2;\r\n    } else {\r\n      hx = hx / 3 + B1;\r\n    }\r\n    u &= 1 << 63;\r\n    u |= <u64>hx << 32;\r\n    var t = reinterpret<f64>(u);\r\n    var r = (t * t) * (t / x);\r\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\r\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\r\n    var s = t * t;\r\n    r = x / s;\r\n    r = (r - t) / (2 * t + r);\r\n    t = t + t * r;\r\n    return t;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function ceil(x: f64): f64 {\r\n    return builtin_ceil<f64>(x);\r\n  }\r\n\r\n  export function clz32(x: f64): f64 {\r\n    if (!isFinite(x)) return 32;\r\n    /*\r\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\r\n     *\r\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\r\n     * our float-point arguments before actual convertion to integers.\r\n     */\r\n    return builtin_clz(dtoi32(x));\r\n  }\r\n\r\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\r\n    var u  = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var sign = ix >> 31;\r\n\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    /* |x| ~< pi/4 */\r\n    if (ix <= 0x3FE921FB) {\r\n      if (ix < 0x3E46A09E) {  /* |x| < 2**-27 * sqrt(2) */\r\n        return 1.0;\r\n      }\r\n      return cos_kern(x, 0);\r\n    }\r\n\r\n    /* sin(Inf or NaN) is NaN */\r\n    if (ix >= 0x7FF00000) return x - x;\r\n\r\n    /* argument reduction needed */\r\n    var n  = rempio2(x, u, sign);\r\n    var y0 = rempio2_y0;\r\n    var y1 = rempio2_y1;\r\n\r\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\r\n    return (n + 1) & 2 ? -x : x;\r\n  }\r\n\r\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\r\n    var u = reinterpret<u64>(x);\r\n    u &= 0x7FFFFFFFFFFFFFFF;\r\n    x = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    if (w < 0x3FE62E42) {\r\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\r\n      t = expm1(x);\r\n      // return 1 + t * t / (2 * (1 + t));\r\n      return 1 + t * t / (2 + 2 * t);\r\n    }\r\n    if (w < 0x40862E42) {\r\n      t = exp(x);\r\n      return 0.5 * (t + 1 / t);\r\n    }\r\n    t = expo2(x);\r\n    return t;\r\n  }\r\n\r\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\r\n      ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\r\n      invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n      P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\r\n      P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\r\n      P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\r\n      P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\r\n      P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\r\n      overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\r\n      underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\r\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var sign_ = <i32>(hx >> 31);\r\n    hx &= 0x7FFFFFFF;\r\n    if (hx >= 0x4086232B) {\r\n      if (isNaN(x)) return x;\r\n      if (x > overflow)  return x * Ox1p1023;\r\n      if (x < underflow) return 0;\r\n    }\r\n    var hi: f64, lo: f64 = 0;\r\n    var k = 0;\r\n    if (hx > 0x3FD62E42) {\r\n      if (hx >= 0x3FF0A2B2) {\r\n        k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\r\n      } else {\r\n        k = 1 - (sign_ << 1);\r\n      }\r\n      hi = x - k * ln2hi;\r\n      lo = k * ln2lo;\r\n      x = hi - lo;\r\n    } else if (hx > 0x3E300000) {\r\n      hi = x;\r\n    } else return 1.0 + x;\r\n    var xs = x * x;\r\n    // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\r\n    var xq = xs * xs;\r\n    var c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\r\n    var y = 1.0 + (x * c / (2 - c) - lo + hi);\r\n    if (k == 0) return y;\r\n    return scalbn(y, k);\r\n  }\r\n\r\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\r\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\r\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\r\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\r\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\r\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\r\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\r\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\r\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\r\n    var k = 0, sign_ = <i32>(u >> 63);\r\n    if (hx >= 0x4043687A) {\r\n      if (isNaN(x)) return x;\r\n      if (sign_) return -1;\r\n      if (x > o_threshold) return x * Ox1p1023;\r\n    }\r\n    var c = 0.0, t: f64;\r\n    if (hx > 0x3FD62E42) {\r\n      k = select<i32>(\r\n        1 - (sign_ << 1),\r\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\r\n        hx < 0x3FF0A2B2\r\n      );\r\n      t = <f64>k;\r\n      let hi = x - t * ln2_hi;\r\n      let lo = t * ln2_lo;\r\n      x = hi - lo;\r\n      c = (hi - x) - lo;\r\n    } else if (hx < 0x3C900000) return x;\r\n    var hfx = 0.5 * x;\r\n    var hxs = x * hfx;\r\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\r\n    var hxq = hxs * hxs;\r\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\r\n    t = 3.0 - r1 * hfx;\r\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\r\n    if (k == 0) return x - (x * e - hxs);\r\n    e = x * (e - c) - c;\r\n    e -= hxs;\r\n    if (k == -1) return 0.5 * (x - e) - 0.5;\r\n    if (k == 1) {\r\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\r\n      return 1.0 + 2.0 * (x - e);\r\n    }\r\n    u = (0x3FF + k) << 52;\r\n    var twopk = reinterpret<f64>(u);\r\n    var y: f64;\r\n    if (k < 0 || k > 56) {\r\n      y = x - e + 1.0;\r\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\r\n      else y = y * twopk;\r\n      return y - 1.0;\r\n    }\r\n    u = (0x3FF - k) << 52;\r\n    y = reinterpret<f64>(u);\r\n    if (k < 20) y = (1 - y) - e;\r\n    else y = 1 - (e + y);\r\n    return (x + y) * twopk;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function floor(x: f64): f64 {\r\n    return builtin_floor<f64>(x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function fround(x: f64): f64 {\r\n    return <f32>x;\r\n  }\r\n\r\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\r\n    const\r\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\r\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\r\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    ux &= 0x7FFFFFFFFFFFFFFF;\r\n    uy &= 0x7FFFFFFFFFFFFFFF;\r\n    if (ux < uy) {\r\n      let ut = ux;\r\n      ux = uy;\r\n      uy = ut;\r\n    }\r\n    var ex = <i32>(ux >> 52);\r\n    var ey = <i32>(uy >> 52);\r\n    y = reinterpret<f64>(uy);\r\n    if (ey == 0x7FF) return y;\r\n    x = reinterpret<f64>(ux);\r\n    if (ex == 0x7FF || uy == 0) return x;\r\n    if (ex - ey > 64) return x + y;\r\n    var z = 1.0;\r\n    if (ex > 0x3FF + 510) {\r\n      z  = Ox1p700;\r\n      x *= Ox1p_700;\r\n      y *= Ox1p_700;\r\n    } else if (ey < 0x3FF - 450) {\r\n      z  = Ox1p_700;\r\n      x *= Ox1p700;\r\n      y *= Ox1p700;\r\n    }\r\n    var c = x * SPLIT;\r\n    var h = x - c + c;\r\n    var l = x - h;\r\n    var hx = x * x;\r\n    var lx = h * h - hx + (2 * h + l) * l;\r\n    c = y * SPLIT;\r\n    h = y - c + c;\r\n    l = y - h;\r\n    var hy = y * y;\r\n    var ly = h * h - hy + (2 * h + l) * l;\r\n    return z * builtin_sqrt(ly + lx + hy + hx);\r\n  }\r\n\r\n  export function imul(x: f64, y: f64): f64 {\r\n    /*\r\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\r\n     *\r\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\r\n     * our float-point arguments before actual convertion to integers.\r\n     */\r\n    if (!isFinite(x + y)) return 0;\r\n    return dtoi32(x) * dtoi32(y);\r\n  }\r\n\r\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\r\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\r\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 0;\r\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (hx >> 31)    return (x - x) / 0.0;\r\n      k -= 54;\r\n      x *= Ox1p54;\r\n      u = reinterpret<u64>(x);\r\n      hx = <u32>(u >> 32);\r\n    } else if (hx >= 0x7FF00000) return x;\r\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\r\n    hx += 0x3FF00000 - 0x3FE6A09E;\r\n    k += (<i32>hx >> 20) - 0x3FF;\r\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n    x = reinterpret<f64>(u);\r\n    var f = x - 1.0;\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var dk = <f64>k;\r\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\r\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\r\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\r\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\r\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 0;\r\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (hx >> 31) return (x - x) / 0.0;\r\n      k -= 54;\r\n      x *= Ox1p54;\r\n      u = reinterpret<u64>(x);\r\n      hx = <u32>(u >> 32);\r\n    } else if (hx >= 0x7FF00000) return x;\r\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\r\n    hx += 0x3FF00000 - 0x3FE6A09E;\r\n    k += <i32>(hx >> 20) - 0x3FF;\r\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n    x = reinterpret<f64>(u);\r\n    var f = x - 1.0;\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var hi = f - hfsq;\r\n    u = reinterpret<u64>(hi);\r\n    u &= 0xFFFFFFFF00000000;\r\n    hi = reinterpret<f64>(u);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var val_hi = hi * ivln10hi;\r\n    var dk = <f64>k;\r\n    var y = dk * log10_2hi;\r\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\r\n    w = y + val_hi;\r\n    val_lo += (y - w) + val_hi;\r\n    return val_lo + w;\r\n  }\r\n\r\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\r\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\r\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 1;\r\n    var c = 0.0, f = 0.0;\r\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\r\n      if (hx >= 0xBFF00000) {\r\n        if (x == -1) return x / 0.0;\r\n        return (x - x) / 0.0;\r\n      }\r\n      if (hx << 1 < 0x3CA00000 << 1) return x;\r\n      if (hx <= 0xBFD2BEC4) {\r\n        k = 0;\r\n        c = 0;\r\n        f = x;\r\n      }\r\n    } else if (hx >= 0x7FF00000) return x;\r\n    if (k) {\r\n      u = reinterpret<u64>(1 + x);\r\n      let hu = <u32>(u >> 32);\r\n      hu += 0x3FF00000 - 0x3FE6A09E;\r\n      k = <i32>(hu >> 20) - 0x3FF;\r\n      if (k < 54) {\r\n        let uf = reinterpret<f64>(u);\r\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\r\n        c /= uf;\r\n      } else c = 0;\r\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\r\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\r\n      f = reinterpret<f64>(u) - 1;\r\n    }\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var dk = <f64>k;\r\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\r\n      ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\r\n      Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n      Ox1p54  = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 0;\r\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (hx >> 31) return (x - x) / 0.0;\r\n      k -= 54;\r\n      x *= Ox1p54;\r\n      u = reinterpret<u64>(x);\r\n      hx = <u32>(u >> 32);\r\n    } else if (hx >= 0x7FF00000) return x;\r\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\r\n    hx += 0x3FF00000 - 0x3FE6A09E;\r\n    k += <i32>(hx >> 20) - 0x3FF;\r\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n    x = reinterpret<f64>(u);\r\n    var f = x - 1.0;\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var hi = f - hfsq;\r\n    u = reinterpret<u64>(hi);\r\n    u &= 0xFFFFFFFF00000000;\r\n    hi = reinterpret<f64>(u);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var val_hi = hi * ivln2hi;\r\n    var val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\r\n    var y = <f64>k;\r\n    w = y + val_hi;\r\n    val_lo += (y - w) + val_hi;\r\n    val_hi = w;\r\n    return val_lo + val_hi;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function max(value1: f64, value2: f64): f64 {\r\n    return builtin_max<f64>(value1, value2);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function min(value1: f64, value2: f64): f64 {\r\n    return builtin_min<f64>(value1, value2);\r\n  }\r\n\r\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\r\n      dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\r\n      two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\r\n      huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\r\n      tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\r\n      L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\r\n      L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\r\n      L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\r\n      L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\r\n      L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\r\n      L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\r\n      P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\r\n      P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\r\n      P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\r\n      P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\r\n      P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\r\n      lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\r\n      lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\r\n      lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\r\n      ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\r\n      cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\r\n      cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\r\n      cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\r\n      ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n      ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\r\n      ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\r\n      inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\r\n    var u_ = reinterpret<u64>(x);\r\n    var hx = <i32>(u_ >> 32);\r\n    var lx = <u32>u_;\r\n    u_ = reinterpret<u64>(y);\r\n    var hy = <i32>(u_ >> 32);\r\n    var ly = <u32>u_;\r\n    var ix = hx & 0x7FFFFFFF;\r\n    var iy = hy & 0x7FFFFFFF;\r\n    if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\r\n    // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\r\n    if ( // NaN if either arg is NaN\r\n      ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\r\n      iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\r\n    ) return x + y;\r\n    var yisint = 0, k: i32;\r\n    if (hx < 0) {\r\n      if (iy >= 0x43400000) yisint = 2;\r\n      else if (iy >= 0x3FF00000) {\r\n        k = (iy >> 20) - 0x3FF;\r\n        let kcond = k > 20;\r\n        let offset = select<i32>(52, 20, kcond) - k;\r\n        let Ly = select<i32>(ly, iy, kcond);\r\n        let jj = Ly >> offset;\r\n        if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\r\n      }\r\n    }\r\n    if (ly == 0) {\r\n      if (iy == 0x7FF00000) { // y is +-inf\r\n        if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\r\n        else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\r\n        else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\r\n      }\r\n      if (iy == 0x3FF00000) {\r\n        if (hy >= 0) return x;\r\n        return 1 / x;\r\n      }\r\n      if (hy == 0x40000000) return x * x;\r\n      if (hy == 0x3FE00000) {\r\n        if (hx >= 0) return builtin_sqrt(x);\r\n      }\r\n    }\r\n    var ax = builtin_abs<f64>(x), z: f64;\r\n    if (lx == 0) {\r\n      if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\r\n        z = ax;\r\n        if (hy < 0) z = 1.0 / z;\r\n        if (hx < 0) {\r\n          if (((ix - 0x3FF00000) | yisint) == 0) {\r\n            let d = z - z;\r\n            z = d / d;\r\n          } else if (yisint == 1) z = -z;\r\n        }\r\n        return z;\r\n      }\r\n    }\r\n    var s = 1.0;\r\n    if (hx < 0) {\r\n      if (yisint == 0) {\r\n        let d = x - x;\r\n        return d / d;\r\n      }\r\n      if (yisint == 1) s = -1.0;\r\n    }\r\n    var t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\r\n    var j: i32, n: i32;\r\n    if (iy > 0x41E00000) {\r\n      if (iy > 0x43F00000) {\r\n        if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\r\n        if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\r\n      }\r\n      if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\r\n      if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\r\n      t = ax - 1.0;\r\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\r\n      u = ivln2_h * t;\r\n      v = t * ivln2_l - w * ivln2;\r\n      t1 = u + v;\r\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\r\n      t2 = v - (t1 - u);\r\n    } else {\r\n      let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\r\n      n = 0;\r\n      if (ix < 0x00100000) {\r\n        ax *= two53;\r\n        n -= 53;\r\n        ix = <u32>(reinterpret<u64>(ax) >> 32);\r\n      }\r\n      n += (ix >> 20) - 0x3FF;\r\n      j = ix & 0x000FFFFF;\r\n      ix = j | 0x3FF00000;\r\n      if (j <= 0x3988E) k = 0;\r\n      else if (j < 0xBB67A) k = 1;\r\n      else {\r\n        k = 0;\r\n        n += 1;\r\n        ix -= 0x00100000;\r\n      }\r\n      ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\r\n      let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\r\n      u = ax - bp;\r\n      v = 1.0 / (ax + bp);\r\n      ss = u * v;\r\n      s_h = ss;\r\n      s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\r\n      t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\r\n      t_l = ax - (t_h - bp);\r\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\r\n      s2 = ss * ss;\r\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\r\n      r += s_l * (s_h + ss);\r\n      s2 = s_h * s_h;\r\n      t_h = 3.0 + s2 + r;\r\n      t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\r\n      t_l = r - ((t_h - 3.0) - s2);\r\n      u = s_h * t_h;\r\n      v = s_l * t_h + t_l * ss;\r\n      p_h = u + v;\r\n      p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\r\n      p_l = v - (p_h - u);\r\n      let z_h = cp_h * p_h;\r\n      let dp_l = select<f64>(dp_l1, 0.0, k);\r\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\r\n      t = <f64>n;\r\n      let dp_h = select<f64>(dp_h1, 0.0, k);\r\n      t1 = ((z_h + z_l) + dp_h) + t;\r\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\r\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\r\n    }\r\n    var y1 = y;\r\n    y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\r\n    p_l = (y - y1) * t1 + y * t2;\r\n    p_h = y1 * t1;\r\n    z = p_l + p_h;\r\n    u_ = reinterpret<u64>(z);\r\n    j = <u32>(u_ >> 32);\r\n    var i = <i32>u_;\r\n    if (j >= 0x40900000) {\r\n      if (((j - 0x40900000) | i) != 0) return s * huge * huge;\r\n      if (p_l + ovt > z - p_h) return s * huge * huge;\r\n    } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\r\n      if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\r\n      if (p_l <= z - p_h) return s * tiny * tiny;\r\n    }\r\n    i = j & 0x7FFFFFFF;\r\n    k = (i >> 20) - 0x3FF;\r\n    n = 0;\r\n    if (i > 0x3FE00000) {\r\n      n = j + (0x00100000 >> (k + 1));\r\n      k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\r\n      t = 0.0;\r\n      t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\r\n      n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\r\n      if (j < 0) n = -n;\r\n      p_h -= t;\r\n    }\r\n    t = p_l + p_h;\r\n    t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\r\n    u = t * lg2_h;\r\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\r\n    z = u + v;\r\n    w = v - (z - u);\r\n    t = z * z;\r\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\r\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\r\n    z = 1.0 - (r - z);\r\n    j = <u32>(reinterpret<u64>(z) >> 32);\r\n    j += n << 20;\r\n    if ((j >> 20) <= 0) z = scalbn(z, n);\r\n    else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\r\n    return s * z;\r\n  }\r\n\r\n  export function seedRandom(value: i64): void {\r\n    random_seeded = true;\r\n    random_state0_64 = murmurHash3(value);\r\n    random_state1_64 = murmurHash3(~random_state0_64);\r\n    random_state0_32 = splitMix32(<u32>value);\r\n    random_state1_32 = splitMix32(random_state0_32);\r\n    assert(\r\n      random_state0_64 != 0 && random_state1_64 != 0 &&\r\n      random_state0_32 != 0 && random_state1_32 != 0\r\n    );\r\n  }\r\n\r\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\r\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\r\n    var s1 = random_state0_64;\r\n    var s0 = random_state1_64;\r\n    random_state0_64 = s0;\r\n    s1 ^= s1 << 23;\r\n    s1 ^= s1 >> 17;\r\n    s1 ^= s0;\r\n    s1 ^= s0 >> 26;\r\n    random_state1_64 = s1;\r\n    var r = (s0 >> 12) | 0x3FF0000000000000;\r\n    return reinterpret<f64>(r) - 1;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function round(x: f64): f64 {\r\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sign(x: f64): f64 {\r\n    if (ASC_SHRINK_LEVEL > 0) {\r\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\r\n    } else {\r\n      return x > 0 ? 1 : x < 0 ? -1 : x;\r\n    }\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function signbit(x: f64): bool {\r\n    // In ECMAScript all NaN values are indistinguishable from each other\r\n    // so we need handle NaN and negative NaN in similar way\r\n    return <bool>(<i32>(reinterpret<u64>(x) >>> 63) & i32(x == x));\r\n  }\r\n\r\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\r\n    var u  = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var sign = ix >> 31;\r\n\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    /* |x| ~< pi/4 */\r\n    if (ix <= 0x3FE921FB) {\r\n      if (ix < 0x3E500000) { /* |x| < 2**-26 */\r\n        return x;\r\n      }\r\n      return sin_kern(x, 0.0, 0);\r\n    }\r\n\r\n    /* sin(Inf or NaN) is NaN */\r\n    if (ix >= 0x7FF00000) return x - x;\r\n\r\n    /* argument reduction needed */\r\n    var n  = rempio2(x, u, sign);\r\n    var y0 = rempio2_y0;\r\n    var y1 = rempio2_y1;\r\n\r\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\r\n    return n & 2 ? -x : x;\r\n  }\r\n\r\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\r\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\r\n    var absx = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    var h = builtin_copysign(0.5, x);\r\n    if (w < 0x40862E42) {\r\n      t = expm1(absx);\r\n      if (w < 0x3FF00000) {\r\n        if (w < 0x3FF00000 - (26 << 20)) return x;\r\n        return h * (2 * t - t * t / (t + 1));\r\n      }\r\n      return h * (t + t / (t + 1));\r\n    }\r\n    t = 2 * h * expo2(absx);\r\n    return t;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sqrt(x: f64): f64 {\r\n    return builtin_sqrt<f64>(x);\r\n  }\r\n\r\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\r\n    var u = reinterpret<u64>(x);\r\n    var ix = <i32>(u >> 32);\r\n    var sign = ix >>> 31;\r\n\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    /* |x| ~< pi/4 */\r\n    if (ix <= 0x3FE921FB) {\r\n      if (ix < 0x3E400000) { /* |x| < 2**-27 */\r\n        return x;\r\n      }\r\n      return tan_kern(x, 0.0, 1);\r\n    }\r\n\r\n    /* tan(Inf or NaN) is NaN */\r\n    if (ix >= 0x7FF00000) return x - x;\r\n\r\n    var n = rempio2(x, u, sign);\r\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\r\n  }\r\n\r\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\r\n    var u = reinterpret<u64>(x);\r\n    u &= 0x7FFFFFFFFFFFFFFF;\r\n    var y = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    if (w > 0x3FE193EA) {\r\n      if (w > 0x40340000) {\r\n        t = 1 - 0 / y;\r\n      } else {\r\n        t = expm1(2 * y);\r\n        t = 1 - 2 / (t + 2);\r\n      }\r\n    } else if (w > 0x3FD058AE) {\r\n      t = expm1(2 * y);\r\n      t = t / (t + 2);\r\n    } else if (w >= 0x00100000) {\r\n      t = expm1(-2 * y);\r\n      t = -t / (t + 2);\r\n    } else t = y;\r\n    return builtin_copysign<f64>(t, x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function trunc(x: f64): f64 {\r\n    return builtin_trunc<f64>(x);\r\n  }\r\n\r\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\r\n    const\r\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\r\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\r\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\r\n    var y = x;\r\n    if (n > 1023) {\r\n      y *= Ox1p1023;\r\n      n -= 1023;\r\n      if (n > 1023) {\r\n        y *= Ox1p1023;\r\n        n = builtin_min<i32>(n - 1023, 1023);\r\n      }\r\n    } else if (n < -1022) {\r\n      /* make sure final n < -53 to avoid double\r\n       rounding in the subnormal range */\r\n      y *= Ox1p_1022 * Ox1p53;\r\n      n += 1022 - 53;\r\n      if (n < -1022) {\r\n        y *= Ox1p_1022 * Ox1p53;\r\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\r\n      }\r\n    }\r\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\r\n  }\r\n\r\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    var ex = <i64>(ux >> 52 & 0x7FF);\r\n    var ey = <i64>(uy >> 52 & 0x7FF);\r\n    var sx = ux >> 63;\r\n    var uy1 = uy << 1;\r\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\r\n      let m = x * y;\r\n      return m / m;\r\n    }\r\n    var ux1 = ux << 1;\r\n    if (ux1 <= uy1) {\r\n      if (ux1 == uy1) return 0 * x;\r\n      return x;\r\n    }\r\n    if (!ex) {\r\n      ex -= builtin_clz<i64>(ux << 12);\r\n      ux <<= -ex + 1;\r\n    } else {\r\n      ux &= <u64>-1 >> 12;\r\n      ux |= 1 << 52;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<i64>(uy << 12);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u64>-1 >> 12;\r\n      uy |= 1 << 52;\r\n    }\r\n    while (ex > ey) {\r\n      if (ux >= uy) {\r\n        if (ux == uy) return 0 * x;\r\n        ux -= uy;\r\n      }\r\n      ux <<= 1;\r\n      --ex;\r\n    }\r\n    if (ux >= uy) {\r\n      if (ux == uy) return 0 * x;\r\n      ux -= uy;\r\n    }\r\n    // for (; !(ux >> 52); ux <<= 1) --ex;\r\n    var shift = builtin_clz<i64>(ux << 11);\r\n    ex -= shift;\r\n    ux <<= shift;\r\n    if (ex > 0) {\r\n      ux -= 1 << 52;\r\n      ux |= ex << 52;\r\n    } else {\r\n      ux >>= -ex + 1;\r\n    }\r\n    ux |= sx << 63;\r\n    return reinterpret<f64>(ux);\r\n  }\r\n\r\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    var ex = <i64>(ux >> 52 & 0x7FF);\r\n    var ey = <i64>(uy >> 52 & 0x7FF);\r\n    var sx = <i32>(ux >> 63);\r\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\r\n      let m = x * y;\r\n      return m / m;\r\n    }\r\n    if (ux << 1 == 0) return x;\r\n    var uxi = ux;\r\n    if (!ex) {\r\n      ex -= builtin_clz<i64>(uxi << 12);\r\n      uxi <<= -ex + 1;\r\n    } else {\r\n      uxi &= <u64>-1 >> 12;\r\n      uxi |= 1 << 52;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<i64>(uy << 12);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u64>-1 >> 12;\r\n      uy |= 1 << 52;\r\n    }\r\n    var q: u32 = 0;\r\n    do {\r\n      if (ex < ey) {\r\n        if (ex + 1 == ey) break; // goto end\r\n        return x;\r\n      }\r\n      while (ex > ey) {\r\n        if (uxi >= uy) {\r\n          uxi -= uy;\r\n          ++q;\r\n        }\r\n        uxi <<= 1;\r\n        q <<= 1;\r\n        --ex;\r\n      }\r\n      if (uxi >= uy) {\r\n        uxi -= uy;\r\n        ++q;\r\n      }\r\n      if (uxi == 0) ex = -60;\r\n      else {\r\n        let shift = builtin_clz<i64>(uxi << 11);\r\n        ex -= shift;\r\n        uxi <<= shift;\r\n      }\r\n      break;\r\n    } while (false);\r\n  // end:\r\n    if (ex > 0) {\r\n      uxi -= 1 << 52;\r\n      uxi |= ex << 52;\r\n    } else {\r\n      uxi >>= -ex + 1;\r\n    }\r\n    x = reinterpret<f64>(uxi);\r\n    y = builtin_abs<f64>(y);\r\n    var x2 = x + x;\r\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\r\n      x -= y;\r\n      // ++q;\r\n    }\r\n    return sx ? -x : x;\r\n  }\r\n\r\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\r\n    var u = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3FE921FB) { /* |x| ~<= π/4 */\r\n      if (ix < 0x3E46A09E) { /* if |x| < 2**-27 * sqrt(2) */\r\n        sincos_sin = x;\r\n        sincos_cos = 1;\r\n        return;\r\n      }\r\n      sincos_sin = sin_kern(x, 0, 0);\r\n      sincos_cos = cos_kern(x, 0);\r\n      return;\r\n    }\r\n    /* sin(Inf or NaN) is NaN */\r\n    if (ix >= 0x7F800000) {\r\n      let xx = x - x;\r\n      sincos_sin = xx;\r\n      sincos_cos = xx;\r\n      return;\r\n    }\r\n    /* general argument reduction needed */\r\n    var n = rempio2(x, u, sign);\r\n    var y0 = rempio2_y0;\r\n    var y1 = rempio2_y1;\r\n    var s = sin_kern(y0, y1, 1);\r\n    var c = cos_kern(y0, y1);\r\n    var sin = s, cos = c;\r\n    if (n & 1) {\r\n      sin =  c;\r\n      cos = -s;\r\n    }\r\n    if (n & 2) {\r\n      sin = -sin;\r\n      cos = -cos;\r\n    }\r\n    sincos_sin = sin;\r\n    sincos_cos = cos;\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar rempio2f_y: f64;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nconst PIO2F_TABLE: u64[] = [\r\n  0xA2F9836E4E441529,\r\n  0xFC2757D1F534DDC0,\r\n  0xDB6295993C439041,\r\n  0xFE5163ABDEBBC561\r\n];\r\n\r\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\r\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\r\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\r\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\r\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\r\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\r\n  var p = z * (pS0 + z * (pS1 + z * pS2));\r\n  var q: f32 = 1 + z * qS1;\r\n  return p / q;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction expo2f(x: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\r\n  const                                // see: musl/src/math/__expo2f.c\r\n    k    = <u32>235,\r\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\r\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\r\n  return NativeMathf.exp(x - kln2) * scale * scale;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\r\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\r\n  const bits = PIO2F_TABLE.dataStart;\r\n\r\n  var offset = (u >> 23) - 152;\r\n  var shift  = <u64>(offset & 63);\r\n  var tblPtr = bits + (offset >> 6 << 3);\r\n\r\n  var b0 = load<u64>(tblPtr, 0 << 3);\r\n  var b1 = load<u64>(tblPtr, 1 << 3);\r\n  var lo: u64;\r\n\r\n  if (shift > 32) {\r\n    let b2 = load<u64>(tblPtr, 2 << 3);\r\n    lo  = b2 >> (96 - shift);\r\n    lo |= b1 << (shift - 32);\r\n  } else {\r\n    lo = b1 >> (32 - shift);\r\n  }\r\n\r\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\r\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\r\n  var product = mantissa * hi + (mantissa * lo >> 32);\r\n  var r: i64 = product << 2;\r\n  var q = <i32>((product >> 62) + (r >>> 63));\r\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\r\n  return q;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\r\n  const pi2hi = reinterpret<f64>(0x3FF921FB50000000); // 1.57079631090164184570\r\n  const pi2lo = reinterpret<f64>(0x3E5110B4611A6263); // 1.58932547735281966916e-8\r\n  const _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\r\n\r\n  if (u < 0x4DC90FDB) { /* π * 0x1p28 */\r\n    let q = nearest(x * _2_pi);\r\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\r\n    return <i32>q;\r\n  }\r\n\r\n  var q = pio2f_large_quot(x, u);\r\n  return select(-q, q, sign);\r\n}\r\n\r\n/* |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]). */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\r\n  const S1 = reinterpret<f64>(0xBFC5555554CBAC77); // -0x15555554cbac77.0p-55\r\n  const S2 = reinterpret<f64>(0x3F811110896EFBB2); //  0x111110896efbb2.0p-59\r\n  const S3 = reinterpret<f64>(0xBF2A00F9E2CAE774); // -0x1a00f9e2cae774.0p-65\r\n  const S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = S3 + z * S4;\r\n  var s = z * x;\r\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\r\n}\r\n\r\n/* |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]). */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\r\n  const C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81); // -0x1ffffffd0c5e81.0p-54\r\n  const C1 = reinterpret<f64>(0x3FA55553E1053A42); //  0x155553e1053a42.0p-57\r\n  const C2 = reinterpret<f64>(0xBF56C087E80F1E27); // -0x16c087e80f1e27.0p-62\r\n  const C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = C2 + z * C3;\r\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\r\n}\r\n\r\n/* |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]). */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\r\n\r\n  const T0 = reinterpret<f64>(0x3FD5554D3418C99F); /* 0x15554d3418c99f.0p-54 */\r\n  const T1 = reinterpret<f64>(0x3FC112FD38999F72); /* 0x1112fd38999f72.0p-55 */\r\n  const T2 = reinterpret<f64>(0x3FAB54C91D865AFE); /* 0x1b54c91d865afe.0p-57 */\r\n  const T3 = reinterpret<f64>(0x3F991DF3908C33CE); /* 0x191df3908c33ce.0p-58 */\r\n  const T4 = reinterpret<f64>(0x3F685DADFCECF44E); /* 0x185dadfcecf44e.0p-61 */\r\n  const T5 = reinterpret<f64>(0x3F8362B9BF971BCD); /* 0x1362b9bf971bcd.0p-59 */\r\n\r\n  var z = x * x;\r\n  var r = T4 + z * T5;\r\n  var t = T2 + z * T3;\r\n  var w = z * z;\r\n  var s = z * x;\r\n  var u = T0 + z * T1;\r\n\r\n  r = (x + s * u) + (s * w) * (t + w * r);\r\n  return <f32>(odd ? -1 / r : r);\r\n}\r\n\r\nexport namespace NativeMathf {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const E       = <f32>NativeMath.E;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN2     = <f32>NativeMath.LN2;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN10    = <f32>NativeMath.LN10;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG2E   = <f32>NativeMath.LOG2E;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG10E  = <f32>NativeMath.LOG10E;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const PI      = <f32>NativeMath.PI;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT2   = <f32>NativeMath.SQRT2;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_sin: f32 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_cos: f32 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function abs(x: f32): f32 {\r\n    return builtin_abs<f32>(x);\r\n  }\r\n\r\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\r\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = reinterpret<u32>(x);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3F800000) {\r\n      if (ix == 0x3F800000) {\r\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\r\n        return 0;\r\n      }\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3F000000) {\r\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\r\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\r\n    }\r\n    var z: f32, w: f32, s: f32;\r\n    if (hx >> 31) {\r\n      // z = (1 + x) * 0.5;\r\n      z = 0.5 + x * 0.5;\r\n      s = builtin_sqrt<f32>(z);\r\n      w = Rf(z) * s - pio2_lo;\r\n      return 2 * (pio2_hi - (s + w));\r\n    }\r\n    // z = (1 - x) * 0.5;\r\n    z = 0.5 - x * 0.5;\r\n    s = builtin_sqrt<f32>(z);\r\n    hx = reinterpret<u32>(s);\r\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\r\n    var c = (z - df * df) / (s + df);\r\n    w = Rf(z) * s + c;\r\n    return 2 * (df + w);\r\n  }\r\n\r\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\r\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\r\n    var u = reinterpret<u32>(x);\r\n    var a = u & 0x7FFFFFFF;\r\n    if (a < 0x3F800000 + (1 << 23)) {\r\n      let xm1 = x - 1;\r\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\r\n    }\r\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\r\n    return log(x) + s;\r\n  }\r\n\r\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var sx = x;\r\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    if (hx >= 0x3F800000) {\r\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\r\n      return 0 / (x - x);\r\n    }\r\n    if (hx < 0x3F000000) {\r\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\r\n      return x + x * Rf(x * x);\r\n    }\r\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\r\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\r\n    var s = builtin_sqrt<f64>(z); // sic\r\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\r\n    return builtin_copysign(x, sx);\r\n  }\r\n\r\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\r\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\r\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    var y = reinterpret<f32>(u);\r\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\r\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\r\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\r\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\r\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\r\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\r\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\r\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\r\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\r\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\r\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\r\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\r\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\r\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\r\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var ix = reinterpret<u32>(x);\r\n    var sx = x;\r\n    ix &= 0x7FFFFFFF;\r\n    var z: f32;\r\n    if (ix >= 0x4C800000) {\r\n      if (isNaN(x)) return x;\r\n      z = atanhi3 + Ox1p_120f;\r\n      return builtin_copysign(z, sx);\r\n    }\r\n    var id: i32;\r\n    if (ix < 0x3EE00000) {\r\n      if (ix < 0x39800000) return x;\r\n      id = -1;\r\n    } else {\r\n      x = builtin_abs<f32>(x);\r\n      if (ix < 0x3F980000) {\r\n        if (ix < 0x3F300000) {\r\n          id = 0;\r\n          x = (2.0 * x - 1.0) / (2.0 + x);\r\n        } else {\r\n          id = 1;\r\n          x = (x - 1.0) / (x + 1.0);\r\n        }\r\n      } else {\r\n        if (ix < 0x401C0000) {\r\n          id = 2;\r\n          x = (x - 1.5) / (1.0 + 1.5 * x);\r\n        } else {\r\n          id = 3;\r\n          x = -1.0 / x;\r\n        }\r\n      }\r\n    }\r\n    z = x * x;\r\n    var w = z * z;\r\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\r\n    var s2 = w * (aT1 + w * aT3);\r\n    var s3 = x * (s1 + s2);\r\n    if (id < 0) return x - s3;\r\n    switch (id) {\r\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\r\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\r\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\r\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\r\n      default: unreachable();\r\n    }\r\n    return builtin_copysign(z, sx);\r\n  }\r\n\r\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\r\n    var u = reinterpret<u32>(x);\r\n    var y = builtin_abs(x);\r\n    if (u < 0x3F800000 - (1 << 23)) {\r\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\r\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\r\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\r\n    if (isNaN(x) || isNaN(y)) return x + y;\r\n    var ix = reinterpret<u32>(x);\r\n    var iy = reinterpret<u32>(y);\r\n    if (ix == 0x3F800000) return atan(y);\r\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\r\n    ix &= 0x7FFFFFFF;\r\n    iy &= 0x7FFFFFFF;\r\n    if (iy == 0) {\r\n      switch (m) {\r\n        case 0:\r\n        case 1: return  y;\r\n        case 2: return  pi;\r\n        case 3: return -pi;\r\n      }\r\n    }\r\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\r\n    if (ix == 0x7F800000) {\r\n      if (iy == 0x7F800000) {\r\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\r\n        return m & 1 ? -t : t;\r\n      } else {\r\n        let t: f32 = m & 2 ? pi : 0.0;\r\n        return m & 1 ? -t : t;\r\n      }\r\n    }\r\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\r\n    var z: f32;\r\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\r\n    else z = atan(builtin_abs<f32>(y / x));\r\n    switch (m) {\r\n      case 0: return  z;\r\n      case 1: return -z;\r\n      case 2: return pi - (z - pi_lo);\r\n      case 3: return (z - pi_lo) - pi;\r\n    }\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      B1      = <u32>709958130,\r\n      B2      = <u32>642849266,\r\n      Ox1p24f = reinterpret<f32>(0x4B800000);\r\n    var u = reinterpret<u32>(x);\r\n    var hx = u & 0x7FFFFFFF;\r\n    if (hx >= 0x7F800000) return x + x;\r\n    if (hx < 0x00800000) {\r\n      if (hx == 0) return x;\r\n      u = reinterpret<u32>(x * Ox1p24f);\r\n      hx = u & 0x7FFFFFFF;\r\n      hx = hx / 3 + B2;\r\n    } else {\r\n      hx = hx / 3 + B1;\r\n    }\r\n    u &= 0x80000000;\r\n    u |= hx;\r\n    var t = <f64>reinterpret<f32>(u);\r\n    var r = t * t * t;\r\n    t = t * (<f64>x + x + r) / (x + r + r);\r\n    r = t * t * t;\r\n    t = t * (<f64>x + x + r) / (x + r + r);\r\n    return <f32>t;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function ceil(x: f32): f32 {\r\n    return builtin_ceil<f32>(x);\r\n  }\r\n\r\n  export function clz32(x: f32): f32 {\r\n    if (!isFinite(x)) return 32;\r\n    return <f32>builtin_clz(dtoi32(x));\r\n  }\r\n\r\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\r\n    const c1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\r\n    const c2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\r\n    const c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\r\n    const c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\r\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\r\n        /* raise inexact if x != 0 */\r\n        return 1;\r\n      }\r\n      return cos_kernf(x);\r\n    }\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {  /* |x| ~<= 5π/4 */\r\n        if (ix > 0x4016CBE3) { /* |x|  ~> 3π/4 */\r\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\r\n        } else {\r\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\r\n        }\r\n      }\r\n      if (ix <= 0x40E231D5) {  /* |x| ~<= 9π/4 */\r\n        if (ix > 0x40AFEDDF) { /* |x|  ~> 7π/4 */\r\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\r\n        } else {\r\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\r\n        }\r\n      }\r\n    }\r\n\r\n    /* cos(Inf or NaN) is NaN */\r\n    if (ix >= 0x7F800000) return x - x;\r\n\r\n    /* general argument reduction needed */\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n\r\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\r\n    return (n + 1) & 2 ? -t : t;\r\n  }\r\n\r\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\r\n    var u = reinterpret<u32>(x);\r\n    u &= 0x7FFFFFFF;\r\n    x = reinterpret<f32>(u);\r\n    if (u < 0x3F317217) {\r\n      if (u < 0x3F800000 - (12 << 23)) return 1;\r\n      let t = expm1(x);\r\n      // return 1 + t * t / (2 * (1 + t));\r\n      return 1 + t * t / (2 + 2 * t);\r\n    }\r\n    if (u < 0x42B17217) {\r\n      let t = exp(x);\r\n      // return 0.5 * (t + 1 / t);\r\n      return 0.5 * t + 0.5 / t;\r\n    }\r\n    return expo2f(x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function floor(x: f32): f32 {\r\n    return builtin_floor<f32>(x);\r\n  }\r\n\r\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\r\n      ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\r\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\r\n      P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\r\n      P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\r\n      Ox1p127f = reinterpret<f32>(0x7F000000);\r\n    var hx = reinterpret<u32>(x);\r\n    var sign_ = <i32>(hx >> 31);\r\n    hx &= 0x7FFFFFFF;\r\n    if (hx >= 0x42AEAC50) {\r\n      if (hx >= 0x42B17218) {\r\n        if (!sign_) return x * Ox1p127f;\r\n        else if (hx >= 0x42CFF1B5) return 0;\r\n      }\r\n    }\r\n    var hi: f32, lo: f32;\r\n    var k: i32;\r\n    if (hx > 0x3EB17218) {\r\n      if (hx > 0x3F851592) {\r\n        k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\r\n      } else {\r\n        k = 1 - (sign_ << 1);\r\n      }\r\n      hi = x - <f32>k * ln2hi;\r\n      lo = <f32>k * ln2lo;\r\n      x = hi - lo;\r\n    } else if (hx > 0x39000000) {\r\n      k = 0;\r\n      hi = x;\r\n      lo = 0;\r\n    } else {\r\n      return 1 + x;\r\n    }\r\n    var xx = x * x;\r\n    var c = x - xx * (P1 + xx * P2);\r\n    var y: f32 = 1 + (x * c / (2 - c) - lo + hi);\r\n    if (k == 0) return y;\r\n    return scalbn(y, k);\r\n  }\r\n\r\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\r\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\r\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\r\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\r\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\r\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\r\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\r\n    var u = reinterpret<u32>(x);\r\n    var hx = u & 0x7FFFFFFF;\r\n    var sign_ = <i32>(u >> 31);\r\n    if (hx >= 0x4195B844) {\r\n      if (hx > 0x7F800000) return x;\r\n      if (sign_) return -1;\r\n      if (x > o_threshold) {\r\n        x *= Ox1p127f;\r\n        return x;\r\n      }\r\n    }\r\n    var c: f32 = 0.0, t: f32, k: i32;\r\n    if (hx > 0x3EB17218) {\r\n      k = select<i32>(\r\n        1 - (sign_ << 1),\r\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\r\n        hx < 0x3F851592\r\n      );\r\n      t = <f32>k;\r\n      let hi = x - t * ln2_hi;\r\n      let lo = t * ln2_lo;\r\n      x = hi - lo;\r\n      c = (hi - x) - lo;\r\n    } else if (hx < 0x33000000) {\r\n      return x;\r\n    } else k = 0;\r\n    var hfx: f32 = 0.5 * x;\r\n    var hxs: f32 = x * hfx;\r\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\r\n    t  = 3.0 - r1 * hfx;\r\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\r\n    if (k == 0) return x - (x * e - hxs);\r\n    e  = x * (e - c) - c;\r\n    e -= hxs;\r\n    if (k == -1) return 0.5 * (x - e) - 0.5;\r\n    if (k == 1) {\r\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\r\n      return 1.0 + 2.0 * (x - e);\r\n    }\r\n    u = (0x7F + k) << 23;\r\n    var twopk = reinterpret<f32>(u);\r\n    var y: f32;\r\n    if (k < 0 || k > 56) {\r\n      y = x - e + 1.0;\r\n      if (k == 128) y = y * 2.0 * Ox1p127f;\r\n      else y = y * twopk;\r\n      return y - 1.0;\r\n    }\r\n    u = (0x7F - k) << 23;\r\n    y = reinterpret<f32>(u);\r\n    if (k < 20) y = (1 - y) - e;\r\n    else y = 1 - (e + y);\r\n    return (x + y) * twopk;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function fround(x: f32): f32 {\r\n    return x;\r\n  }\r\n\r\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\r\n    const\r\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\r\n      Ox1p_90f = reinterpret<f32>(0x12800000);\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    ux &= 0x7FFFFFFF;\r\n    uy &= 0x7FFFFFFF;\r\n    if (ux < uy) {\r\n      let ut = ux;\r\n      ux = uy;\r\n      uy = ut;\r\n    }\r\n    x = reinterpret<f32>(ux);\r\n    y = reinterpret<f32>(uy);\r\n    if (uy == 0xFF << 23) return y;\r\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\r\n    var z: f32 = 1;\r\n    if (ux >= (0x7F + 60) << 23) {\r\n      z  = Ox1p90f;\r\n      x *= Ox1p_90f;\r\n      y *= Ox1p_90f;\r\n    } else if (uy < (0x7F - 60) << 23) {\r\n      z  = Ox1p_90f;\r\n      x *= Ox1p90f;\r\n      y *= Ox1p90f;\r\n    }\r\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function imul(x: f32, y: f32): f32 {\r\n    /*\r\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\r\n     *\r\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\r\n     * our float-point arguments before actual convertion to integers.\r\n     */\r\n    if (!isFinite(x + y)) return 0;\r\n    return <f32>(dtoi32(x) * dtoi32(y));\r\n  }\r\n\r\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\r\n      ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\r\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\r\n      Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\r\n      Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\r\n      Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\r\n      Ox1p25f = reinterpret<f32>(0x4C000000);\r\n    var u = reinterpret<u32>(x);\r\n    var k = 0;\r\n    if (u < 0x00800000 || <bool>(u >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (u >> 31) return (x - x) / 0;\r\n      k -= 25;\r\n      x *= Ox1p25f;\r\n      u = reinterpret<u32>(x);\r\n    } else if (u >= 0x7F800000) return x;\r\n      else if (u == 0x3F800000) return 0;\r\n    u += 0x3F800000 - 0x3F3504F3;\r\n    k += <u32>(<i32>u >> 23) - 0x7F;\r\n    u = (u & 0x007FFFFF) + 0x3F3504F3;\r\n    x = reinterpret<f32>(u);\r\n    var f = x - 1.0;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq = <f32>0.5 * f * f;\r\n    var dk = <f32>k;\r\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\r\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\r\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\r\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\r\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\r\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\r\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\r\n    var ix = reinterpret<u32>(x);\r\n    var k = 0;\r\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\r\n      if (ix << 1 == 0) return -1 / (x * x);\r\n      if (ix >> 31) return (x - x) / 0.0;\r\n      k -= 25;\r\n      x *= Ox1p25f;\r\n      ix = reinterpret<u32>(x);\r\n    } else if (ix >= 0x7F800000) return x;\r\n      else if (ix == 0x3F800000) return 0;\r\n    ix += 0x3F800000 - 0x3F3504F3;\r\n    k += <i32>(ix >> 23) - 0x7F;\r\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\r\n    x = reinterpret<f32>(ix);\r\n    var f = x - 1.0;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var hi = f - hfsq;\r\n    ix = reinterpret<u32>(hi);\r\n    ix &= 0xFFFFF000;\r\n    hi = reinterpret<f32>(ix);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var dk = <f32>k;\r\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\r\n  }\r\n\r\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\r\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\r\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\r\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\r\n    var ix = reinterpret<u32>(x);\r\n    var c: f32 = 0, f: f32 = 0;\r\n    var k: i32 = 1;\r\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\r\n      if (ix >= 0xBF800000) {\r\n        if (x == -1) return x / 0.0;\r\n        return (x - x) / 0.0;\r\n      }\r\n      if (ix << 1 < 0x33800000 << 1) return x;\r\n      if (ix <= 0xBE95F619) {\r\n        k = 0;\r\n        c = 0;\r\n        f = x;\r\n      }\r\n    } else if (ix >= 0x7F800000) return x;\r\n    if (k) {\r\n      let uf: f32 = 1 + x;\r\n      let iu = reinterpret<u32>(uf);\r\n      iu += 0x3F800000 - 0x3F3504F3;\r\n      k = <i32>(iu >> 23) - 0x7F;\r\n      if (k < 25) {\r\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\r\n        c /= uf;\r\n      } else c = 0;\r\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\r\n      f = reinterpret<f32>(iu) - 1;\r\n    }\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var dk = <f32>k;\r\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\r\n      ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\r\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\r\n      Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\r\n      Ox1p25f = reinterpret<f32>(0x4C000000);\r\n    var ix = reinterpret<u32>(x);\r\n    var k: i32 = 0;\r\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\r\n      if (ix << 1 == 0) return -1 / (x * x);\r\n      if (ix >> 31) return (x - x) / 0.0;\r\n      k -= 25;\r\n      x *= Ox1p25f;\r\n      ix = reinterpret<u32>(x);\r\n    } else if (ix >= 0x7F800000) return x;\r\n      else if (ix == 0x3F800000) return 0;\r\n    ix += 0x3F800000 - 0x3F3504F3;\r\n    k += <i32>(ix >> 23) - 0x7F;\r\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\r\n    x = reinterpret<f32>(ix);\r\n    var f = x - 1.0;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var hi = f - hfsq;\r\n    var u = reinterpret<u32>(hi);\r\n    u &= 0xFFFFF000;\r\n    hi = reinterpret<f32>(u);\r\n    var lo: f32 = f - hi - hfsq + s * (hfsq + r);\r\n    var dk = <f32>k;\r\n    return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function max(value1: f32, value2: f32): f32 {\r\n    return builtin_max<f32>(value1, value2);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function min(value1: f32, value2: f32): f32 {\r\n    return builtin_min<f32>(value1, value2);\r\n  }\r\n\r\n  export function pow(x: f32, y: f32): f32 { // see: musl/src/math/powf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      dp_h1   = reinterpret<f32>(0x3F15C000), //  5.84960938e-01f\r\n      dp_l1   = reinterpret<f32>(0x35D1CFDC), //  1.56322085e-06f\r\n      two24   = reinterpret<f32>(0x4B800000), //  16777216f\r\n      huge    = reinterpret<f32>(0x7149F2CA), //  1.0e+30f\r\n      tiny    = reinterpret<f32>(0x0DA24260), //  1.0e-30f\r\n      L1      = reinterpret<f32>(0x3F19999A), //  6.0000002384e-01f\r\n      L2      = reinterpret<f32>(0x3EDB6DB7), //  4.2857143283e-01f\r\n      L3      = reinterpret<f32>(0x3EAAAAAB), //  3.3333334327e-01f\r\n      L4      = reinterpret<f32>(0x3E8BA305), //  2.7272811532e-01f\r\n      L5      = reinterpret<f32>(0x3E6C3255), //  2.3066075146e-01f\r\n      L6      = reinterpret<f32>(0x3E53F142), //  2.0697501302e-01f\r\n      P1      = reinterpret<f32>(0x3E2AAAAB), //  1.6666667163e-01f\r\n      P2      = reinterpret<f32>(0xBB360B61), // -2.7777778450e-03f\r\n      P3      = reinterpret<f32>(0x388AB355), //  6.6137559770e-05f\r\n      P4      = reinterpret<f32>(0xB5DDEA0E), // -1.6533901999e-06f\r\n      P5      = reinterpret<f32>(0x3331BB4C), //  4.1381369442e-08f\r\n      lg2     = reinterpret<f32>(0x3F317218), //  6.9314718246e-01f\r\n      lg2_h   = reinterpret<f32>(0x3F317200), //  6.93145752e-01f\r\n      lg2_l   = reinterpret<f32>(0x35BFBE8C), //  1.42860654e-06f\r\n      ovt     = reinterpret<f32>(0x3338AA3C), //  4.2995665694e-08f\r\n      cp      = reinterpret<f32>(0x3F76384F), //  9.6179670095e-01\r\n      cp_h    = reinterpret<f32>(0x3F764000), //  9.6191406250e-01\r\n      cp_l    = reinterpret<f32>(0xB8F623C6), // -1.1736857402e-04\r\n      ivln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00\r\n      ivln2_h = reinterpret<f32>(0x3FB8AA00), //  1.4426879883e+00\r\n      ivln2_l = reinterpret<f32>(0x36ECA570), //  7.0526075433e-06\r\n      inv3    = reinterpret<f32>(0x3EAAAAAB);  // 0.333333333333\r\n    var hx = reinterpret<i32>(x);\r\n    var hy = reinterpret<i32>(y);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    var iy = hy & 0x7FFFFFFF;\r\n    if (iy == 0) return 1.0; // x**0 = 1, even if x is NaN\r\n    // if (hx == 0x3F800000) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\r\n    if (ix > 0x7F800000 || iy > 0x7F800000) return x + y; // NaN if either arg is NaN\r\n    var yisint  = 0, j: i32, k: i32;\r\n    if (hx < 0) {\r\n      if (iy >= 0x4B800000) yisint = 2;\r\n      else if (iy >= 0x3F800000) {\r\n        k = (iy >> 23) - 0x7F;\r\n        let ki = 23 - k;\r\n        j = iy >> ki;\r\n        if ((j << ki) == iy) yisint = 2 - (j & 1);\r\n      }\r\n    }\r\n    if (iy == 0x7F800000) { // y is +-inf\r\n      if (ix == 0x3F800000) return NaN; // C: (-1)**+-inf is 1, JS: NaN\r\n      else if (ix > 0x3F800000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\r\n      else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\r\n    }\r\n    if (iy == 0x3F800000) return hy >= 0 ? x : 1.0 / x;\r\n    if (hy == 0x40000000) return x * x;\r\n    if (hy == 0x3F000000) {\r\n      if (hx >= 0) return builtin_sqrt<f32>(x);\r\n    }\r\n    var ax = builtin_abs<f32>(x);\r\n    var z: f32;\r\n    if (ix == 0x7F800000 || ix == 0 || ix == 0x3F800000) {\r\n      z = ax;\r\n      if (hy < 0) z = 1.0 / z;\r\n      if (hx < 0) {\r\n        if (((ix - 0x3F800000) | yisint) == 0) {\r\n          let d = z - z;\r\n          z = d / d;\r\n        }\r\n        else if (yisint == 1) z = -z;\r\n      }\r\n      return z;\r\n    }\r\n    var sn = <f32>1.0;\r\n    if (hx < 0) {\r\n      if (yisint == 0) {\r\n        let d = x - x;\r\n        return d / d;\r\n      }\r\n      if (yisint == 1) sn = -1.0;\r\n    }\r\n    var t1: f32, t2: f32, r: f32, s: f32, t: f32, u: f32, v: f32, w: f32, p_h: f32, p_l: f32;\r\n    var n: i32, is: i32;\r\n    if (iy > 0x4D000000) {\r\n      if (ix < 0x3F7FFFF8) return hy < 0 ? sn * huge * huge : sn * tiny * tiny;\r\n      if (ix > 0x3F800007) return hy > 0 ? sn * huge * huge : sn * tiny * tiny;\r\n      t = ax - 1;\r\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\r\n      u = ivln2_h * t;\r\n      v = t * ivln2_l - w * ivln2;\r\n      t1 = u + v;\r\n      is = reinterpret<i32>(t1);\r\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\r\n      t2 = v - (t1 - u);\r\n    } else {\r\n      let s2: f32, s_h: f32, s_l: f32, t_h: f32, t_l: f32;\r\n      n = 0;\r\n      if (ix < 0x00800000) {\r\n        ax *= two24;\r\n        n -= 24;\r\n        ix = reinterpret<i32>(ax);\r\n      }\r\n      n += (ix >> 23) - 0x7F;\r\n      j = ix & 0x007FFFFF;\r\n      ix = j | 0x3F800000;\r\n      if (j <= 0x1CC471) k = 0;\r\n      else if (j < 0x5DB3D7) k = 1;\r\n      else {\r\n        k = 0;\r\n        n += 1;\r\n        ix -= 0x00800000;\r\n      }\r\n      ax = reinterpret<f32>(ix);\r\n      let bp = select<f32>(1.5, 1.0, k); // k ? 1.5 : 1.0\r\n      u = ax - bp;\r\n      v = 1.0 / (ax + bp);\r\n      s = u * v;\r\n      s_h = s;\r\n      is = reinterpret<u32>(s_h);\r\n      s_h = reinterpret<f32>(is & 0xFFFFF000);\r\n      is = ((ix >> 1) & 0xFFFFF000) | 0x20000000;\r\n      t_h = reinterpret<f32>(is + 0x00400000 + (k << 21));\r\n      t_l = ax - (t_h - bp);\r\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\r\n      s2 = s * s;\r\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\r\n      r += s_l * (s_h + s);\r\n      s2 = s_h * s_h;\r\n      t_h = 3.0 + s2 + r;\r\n      is  = reinterpret<u32>(t_h);\r\n      t_h = reinterpret<f32>(is & 0xFFFFF000);\r\n      t_l = r - ((t_h - 3.0) - s2);\r\n      u = s_h * t_h;\r\n      v = s_l * t_h + t_l * s;\r\n      p_h = u + v;\r\n      is  = reinterpret<u32>(p_h);\r\n      p_h = reinterpret<f32>(is & 0xFFFFF000);\r\n      p_l = v - (p_h - u);\r\n      let z_h = cp_h * p_h;\r\n      let dp_l = select<f32>(dp_l1, 0.0, k);\r\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\r\n      t = <f32>n;\r\n      let dp_h = select<f32>(dp_h1, 0.0, k);\r\n      t1 = (((z_h + z_l) + dp_h) + t);\r\n      is = reinterpret<u32>(t1);\r\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\r\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\r\n    }\r\n    is = reinterpret<u32>(y);\r\n    var y1 = reinterpret<f32>(is & 0xFFFFF000);\r\n    p_l = (y - y1) * t1 + y * t2;\r\n    p_h = y1 * t1;\r\n    z = p_l + p_h;\r\n    j = reinterpret<u32>(z);\r\n    if (j > 0x43000000) {\r\n      return sn * huge * huge;\r\n    } else if (j == 0x43000000) {\r\n      if (p_l + ovt > z - p_h) return sn * huge * huge;\r\n    } else if ((j & 0x7FFFFFFF) > 0x43160000) {\r\n      return sn * tiny * tiny;\r\n    } else if (j == 0xC3160000) {\r\n      if (p_l <= z - p_h) return sn * tiny * tiny;\r\n    }\r\n    var i = j & 0x7FFFFFFF;\r\n    k = (i >> 23) - 0x7F;\r\n    n = 0;\r\n    if (i > 0x3F000000) {\r\n      n = j + (0x00800000 >> (k + 1));\r\n      k = ((n & 0x7FFFFFFF) >> 23) - 0x7F;\r\n      t = reinterpret<f32>(n & ~(0x007FFFFF >> k));\r\n      n = ((n & 0x007FFFFF) | 0x00800000) >> (23 - k);\r\n      if (j < 0) n = -n;\r\n      p_h -= t;\r\n    }\r\n    t = p_l + p_h;\r\n    is = reinterpret<u32>(t);\r\n    t = reinterpret<f32>(is & 0xFFFF8000);\r\n    u = t * lg2_h;\r\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\r\n    z = u + v;\r\n    w = v - (z - u);\r\n    t = z * z;\r\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\r\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\r\n    z = 1.0 - (r - z);\r\n    j = reinterpret<u32>(z);\r\n    j += n << 23;\r\n    if ((j >> 23) <= 0) z = scalbn(z, n);\r\n    else z = reinterpret<f32>(j);\r\n    return sn * z;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function seedRandom(value: i64): void {\r\n    NativeMath.seedRandom(value);\r\n  }\r\n\r\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\r\n  export function random(): f32 {\r\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\r\n\r\n    var s0 = random_state0_32;\r\n    var s1 = random_state1_32;\r\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\r\n\r\n    s1 ^= s0;\r\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\r\n    random_state1_32 = rotl<u32>(s1, 13);\r\n\r\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function round(x: f32): f32 {\r\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sign(x: f32): f32 {\r\n    if (ASC_SHRINK_LEVEL > 0) {\r\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\r\n    } else {\r\n      return x > 0 ? 1 : x < 0 ? -1 : x;\r\n    }\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function signbit(x: f32): bool {\r\n    // @ts-ignore: type\r\n    return <bool>((reinterpret<u32>(x) >>> 31) & (x == x));\r\n  }\r\n\r\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\r\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\r\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\r\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\r\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\r\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\r\n        return x;\r\n      }\r\n      return sin_kernf(x);\r\n    }\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {   /* |x| ~<= 5π/4 */\r\n        if (ix <= 0x4016CBE3) { /* |x| ~<= 3π/4 */\r\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\r\n        }\r\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\r\n      }\r\n\r\n      if (ix <= 0x40E231D5) {   /* |x| ~<= 9π/4 */\r\n        if (ix <= 0x40AFEDDF) { /* |x| ~<= 7π/4 */\r\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\r\n        }\r\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\r\n      }\r\n    }\r\n\r\n    /* sin(Inf or NaN) is NaN */\r\n    if (ix >= 0x7F800000) return x - x;\r\n\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n\r\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\r\n    return n & 2 ? -t : t;\r\n  }\r\n\r\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\r\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    var absx = reinterpret<f32>(u);\r\n    var t: f32;\r\n    var h = builtin_copysign<f32>(0.5, x);\r\n    if (u < 0x42B17217) {\r\n      t = expm1(absx);\r\n      if (u < 0x3F800000) {\r\n        if (u < 0x3F800000 - (12 << 23)) return x;\r\n        return h * (2 * t - t * t / (t + 1));\r\n      }\r\n      return h * (t + t / (t + 1));\r\n    }\r\n    t = 2 * h * expo2f(absx);\r\n    return t;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sqrt(x: f32): f32 {\r\n    return builtin_sqrt<f32>(x);\r\n  }\r\n\r\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\r\n    const t1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\r\n    const t2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\r\n    const t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\r\n    const t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\r\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\r\n        return x;\r\n      }\r\n      return tan_kernf(x, 0);\r\n    }\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {   /* |x| ~<= 5π/4 */\r\n        if (ix <= 0x4016CBE3) { /* |x| ~<= 3π/4 */\r\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\r\n        } else {\r\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\r\n        }\r\n      }\r\n      if (ix <= 0x40E231D5) {   /* |x| ~<= 9π/4 */\r\n        if (ix <= 0x40AFEDDF) { /* |x| ~<= 7π/4 */\r\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\r\n        } else {\r\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    /* tan(Inf or NaN) is NaN */\r\n    if (ix >= 0x7F800000) return x - x;\r\n\r\n    /* argument reduction */\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n    return tan_kernf(y, n & 1);\r\n  }\r\n\r\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\r\n    var u = reinterpret<u32>(x);\r\n    u &= 0x7FFFFFFF;\r\n    var y = reinterpret<f32>(u);\r\n    var t: f32;\r\n    if (u > 0x3F0C9F54) {\r\n      if (u > 0x41200000) t = 1 + 0 / y;\r\n      else {\r\n        t = expm1(2 * y);\r\n        t = 1 - 2 / (t + 2);\r\n      }\r\n    } else if (u > 0x3E82C578) {\r\n      t = expm1(2 * y);\r\n      t = t / (t + 2);\r\n    } else if (u >= 0x00800000) {\r\n      t = expm1(-2 * y);\r\n      t = -t / (t + 2);\r\n    } else t = y;\r\n    return builtin_copysign<f32>(t, x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function trunc(x: f32): f32 {\r\n    return builtin_trunc<f32>(x);\r\n  }\r\n\r\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\r\n    const\r\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\r\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\r\n      Ox1p_126f = reinterpret<f32>(0x00800000);\r\n    var y = x;\r\n    if (n > 127) {\r\n      y *= Ox1p127f;\r\n      n -= 127;\r\n      if (n > 127) {\r\n        y *= Ox1p127f;\r\n        n = builtin_min<i32>(n - 127, 127);\r\n      }\r\n    } else if (n < -126) {\r\n      y *= Ox1p_126f * Ox1p24f;\r\n      n += 126 - 24;\r\n      if (n < -126) {\r\n        y *= Ox1p_126f * Ox1p24f;\r\n        n = builtin_max<i32>(n + 126 - 24, -126);\r\n      }\r\n    }\r\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\r\n  }\r\n\r\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    var ex = <i32>(ux >> 23 & 0xFF);\r\n    var ey = <i32>(uy >> 23 & 0xFF);\r\n    var sx = ux & 0x80000000;\r\n    var uy1 = uy << 1;\r\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\r\n      let m = x * y;\r\n      return m / m;\r\n    }\r\n    var ux1 = ux << 1;\r\n    if (ux1 <= uy1) {\r\n      if (ux1 == uy1) return 0 * x;\r\n      return x;\r\n    }\r\n    if (!ex) {\r\n      ex -= builtin_clz<u32>(ux << 9);\r\n      ux <<= -ex + 1;\r\n    } else {\r\n      ux &= <u32>-1 >> 9;\r\n      ux |= 1 << 23;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<u32>(uy << 9);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u32>-1 >> 9;\r\n      uy |= 1 << 23;\r\n    }\r\n    while (ex > ey) {\r\n      if (ux >= uy) {\r\n        if (ux == uy) return 0 * x;\r\n        ux -= uy;\r\n      }\r\n      ux <<= 1;\r\n      --ex;\r\n    }\r\n    if (ux >= uy) {\r\n      if (ux == uy) return 0 * x;\r\n      ux -= uy;\r\n    }\r\n    // for (; !(ux >> 23); ux <<= 1) --ex;\r\n    var shift = <i32>builtin_clz<u32>(ux << 8);\r\n    ex -= shift;\r\n    ux <<= shift;\r\n    if (ex > 0) {\r\n      ux -= 1 << 23;\r\n      ux |= <u32>ex << 23;\r\n    } else {\r\n      ux >>= -ex + 1;\r\n    }\r\n    ux |= sx;\r\n    return reinterpret<f32>(ux);\r\n  }\r\n\r\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    var ex = <i32>(ux >> 23 & 0xFF);\r\n    var ey = <i32>(uy >> 23 & 0xFF);\r\n    var sx = <i32>(ux >> 31);\r\n    var uxi = ux;\r\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\r\n    if (ux << 1 == 0) return x;\r\n    if (!ex) {\r\n      ex -= builtin_clz<u32>(uxi << 9);\r\n      uxi <<= -ex + 1;\r\n    } else {\r\n      uxi &= <u32>-1 >> 9;\r\n      uxi |= 1 << 23;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<u32>(uy << 9);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u32>-1 >> 9;\r\n      uy |= 1 << 23;\r\n    }\r\n    var q = 0;\r\n    do {\r\n      if (ex < ey) {\r\n        if (ex + 1 == ey) break; // goto end\r\n        return x;\r\n      }\r\n      while (ex > ey) {\r\n        if (uxi >= uy) {\r\n          uxi -= uy;\r\n          ++q;\r\n        }\r\n        uxi <<= 1;\r\n        q <<= 1;\r\n        --ex;\r\n      }\r\n      if (uxi >= uy) {\r\n        uxi -= uy;\r\n        ++q;\r\n      }\r\n      if (uxi == 0) ex = -30;\r\n      else {\r\n        let shift = builtin_clz<i32>(uxi << 8);\r\n        ex -= shift;\r\n        uxi <<= shift;\r\n      }\r\n      break;\r\n    } while (false);\r\n  // end\r\n    if (ex > 0) {\r\n      uxi -= 1 << 23;\r\n      uxi |= <u32>ex << 23;\r\n    } else {\r\n      uxi >>= -ex + 1;\r\n    }\r\n    x = reinterpret<f32>(uxi);\r\n    y = builtin_abs<f32>(y);\r\n    var x2 = x + x;\r\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\r\n      x -= y;\r\n      // q++;\r\n    }\r\n    return sx ? -x : x;\r\n  }\r\n\r\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\r\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\r\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\r\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\r\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\r\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\r\n        sincos_sin = x;\r\n        sincos_cos = 1;\r\n        return;\r\n      }\r\n      sincos_sin = sin_kernf(x);\r\n      sincos_cos = cos_kernf(x);\r\n      return;\r\n    }\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {   /* |x| ~<= 5π/4 */\r\n        if (ix <= 0x4016CBE3) { /* |x| ~<= 3π/4 */\r\n          if (sign) {\r\n            sincos_sin = -cos_kernf(x + s1pio2);\r\n            sincos_cos =  sin_kernf(x + s1pio2);\r\n          } else {\r\n            sincos_sin = cos_kernf(s1pio2 - x);\r\n            sincos_cos = sin_kernf(s1pio2 - x);\r\n          }\r\n          return;\r\n        }\r\n        /* -sin(x + c) is not correct if x+c could be 0: -0 vs +0 */\r\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\r\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\r\n        return;\r\n      }\r\n      if (ix <= 0x40E231D5) {   /* |x| ~<= 9π/4 */\r\n        if (ix <= 0x40AFEDDF) { /* |x| ~<= 7π/4 */\r\n          if (sign) {\r\n            sincos_sin =  cos_kernf(x + s3pio2);\r\n            sincos_cos = -sin_kernf(x + s3pio2);\r\n          } else {\r\n            sincos_sin = -cos_kernf(x - s3pio2);\r\n            sincos_cos =  sin_kernf(x - s3pio2);\r\n          }\r\n          return;\r\n        }\r\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\r\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\r\n        return;\r\n      }\r\n    }\r\n    /* sin(Inf or NaN) is NaN */\r\n    if (ix >= 0x7F800000) {\r\n      let xx = x - x;\r\n      sincos_sin = xx;\r\n      sincos_cos = xx;\r\n      return;\r\n    }\r\n    /* general argument reduction needed */\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n    var s = sin_kernf(y);\r\n    var c = cos_kernf(y);\r\n    var sin = s, cos = c;\r\n    if (n & 1) {\r\n      sin =  c;\r\n      cos = -s;\r\n    }\r\n    if (n & 2) {\r\n      sin = -sin;\r\n      cos = -cos;\r\n    }\r\n    sincos_sin = sin;\r\n    sincos_cos = cos;\r\n  }\r\n}\r\n\r\nexport function ipow32(x: i32, e: i32): i32 {\r\n  var out = 1;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (e < 0) return 0;\r\n\r\n    switch (e) {\r\n      case 0: return 1;\r\n      case 1: return x;\r\n      case 2: return x * x;\r\n    }\r\n\r\n    let log = 32 - clz(e);\r\n    if (log <= 5) {\r\n      // 32 = 2 ^ 5, so need only five cases.\r\n      // But some extra cases needs for properly overflowing\r\n      switch (log) {\r\n        case 5: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 4: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 3: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 2: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 1: {\r\n          if (e & 1) out *= x;\r\n        }\r\n      }\r\n      return out;\r\n    }\r\n  }\r\n\r\n  while (e > 0) {\r\n    if (e & 1) out *= x;\r\n    e >>= 1;\r\n    x *= x;\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function ipow64(x: i64, e: i32): i64 {\r\n  var out: i64 = 1;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (e < 0) return 0;\r\n    switch (e) {\r\n      case 0: return 1;\r\n      case 1: return x;\r\n      case 2: return x * x;\r\n    }\r\n\r\n    let log = 32 - clz(e);\r\n    if (log <= 6) {\r\n      // 64 = 2 ^ 6, so need only six cases.\r\n      // But some extra cases needs for properly overflowing\r\n      switch (log) {\r\n        case 6: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 5: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 4: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 3: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 2: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 1: {\r\n          if (e & 1) out *= x;\r\n        }\r\n      }\r\n      return out;\r\n    }\r\n  }\r\n\r\n  while (e > 0) {\r\n    if (e & 1) out *= x;\r\n    e >>= 1;\r\n    x *= x;\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function ipow32f(x: f32, e: i32): f32 {\r\n  var sign = e >> 31;\r\n  e = (e + sign) ^ sign; // abs(e)\r\n  var out: f32 = 1;\r\n  while (e) {\r\n    out *= select<f32>(x, 1.0, e & 1);\r\n    e >>= 1;\r\n    x *= x;\r\n  }\r\n  return sign ? <f32>1.0 / out : out;\r\n}\r\n\r\nexport function ipow64f(x: f64, e: i32): f64 {\r\n  var sign = e >> 31;\r\n  e = (e + sign) ^ sign; // abs(e)\r\n  var out = 1.0;\r\n  while (e) {\r\n    out *= select(x, 1.0, e & 1);\r\n    e >>= 1;\r\n    x *= x;\r\n  }\r\n  return sign ? 1.0 / out : out;\r\n}\r\n"]}